<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人主页</title>
  
  <subtitle>愿我的只言片语，为你的成长带来帮助！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://myblong.zkb/"/>
  <updated>2019-07-24T15:15:02.279Z</updated>
  <id>https://myblong.zkb/</id>
  
  <author>
    <name>左康波</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>敏捷开发指导思想</title>
    <link href="https://myblong.zkb/2019/07/24/share/%E5%BC%80%E5%8F%91%E7%9A%84%E6%8C%87%E5%AF%BC%E6%80%9D%E6%83%B3/"/>
    <id>https://myblong.zkb/2019/07/24/share/开发的指导思想/</id>
    <published>2019-07-24T14:42:50.152Z</published>
    <updated>2019-07-24T15:15:02.279Z</updated>
    
    <content type="html"><![CDATA[<pre><code>@[TOC](敏捷开发指导思想)</code></pre><a id="more"></a><div class="show-content-free">            <h1>敏捷概述</h1><h2>背景</h2><blockquote><p>敏捷开发最早被提出应用于软件开发管理流程中。随着时代发展，软件规模和复杂度激增，需求变化加快，软件开发过程日益“重型化”，因此轻量级的，更能适应变化的敏捷软件开发方法被普遍认可并迅速发展流行。</p></blockquote><h2>敏捷宣言（原则）</h2><blockquote><p>个体和交互 胜过 过程和工具<br>可以工作的软件 胜过 面面俱到的文档<br>客户合作 胜过 合同谈判<br>响应变化 胜过 遵循计划</p></blockquote><hr><h1>认识敏捷</h1><blockquote><p>统一认识：敏捷=理念（敏捷核心思想）<em>优秀实践（敏捷的经验积累）</em>具体应用（结合自身，灵活应用）</p></blockquote><h2>理念</h2><ol><li><h4>聚焦客户（视觉）价值（Value），消除浪费</h4><ul><li>部分完成但没最终落地的工作。</li><li>开发完成但没有被客户应用的特性。</li><li>人员流动导致经验不能累计，重复学习。</li><li>移交导致信息丢失。</li><li>任务切换（研究表明多任务工作会导致效率下降20%-40%）。</li><li>因任务或资源互相依赖而导致工作停滞。</li><li>缺陷，解决缺陷本身就是浪费，而且缺陷越遗留到后面浪费越大。</li></ul></li><li><h4>激发团队（Team）潜能，加强协作</h4><ul><li><strong>激发团队</strong><ul><li>通过目标牵引团队自主工作</li><li>当团队自管理时效率最高</li><li>当团队成员不被打扰时，工作效率最高</li><li>当团队解决自我问题时，提升最快</li><li>团队成员共同参与计划制定、任务安排，关注团队目标、共担责任</li><li>人们对自己做出的承诺比别人要求的更认真</li><li>人们会尽力做到最好</li><li>在强大的压力下努力工作，会自然降低对质量的要求</li></ul></li><li><strong>沟通协作</strong><ul><li>广泛的面对面的交流是团队工作高效的方式</li><li>白板沟通 优于 电话沟通 优于 邮件沟通 优于 文档、录制的音视频</li></ul></li></ul></li><li><h4>不断调整以适应（Adapting）变化</h4><ul><li><strong>适应变化</strong><ul><li>认清“客户是逐步发现真正的需求”。</li><li>小批量快速交付是关键。</li><li>通过迭代计划不断调整以适应需求变化</li></ul></li><li><strong>应持续保持良好的架构</strong><ul><li>良好的架构是适应变化的基石<ol><li>软件开发特点是内容庞大、内容持续增长、持续周期长，因此需要良好的架构来保证长期的演进</li><li>优秀的架构通过可扩展性来很好的适应需求的变化，对敏捷起到支持作用，相反拙劣的架构会阻碍敏捷</li><li>良好架构有助于定制合适的增量开发/集成计划，使分层分级的可持续集成更加容易</li></ol></li><li>架构需要尽早验证和持续维护<ol><li>通过迭代来实现和验证架构，有利于架构的尽早稳定</li><li>特殊效果表现需识别影响架构的需求，优先实现，规避架构风险</li><li>通过重构及时维护和优化架构，使架构保持生命力</li></ol></li><li>利用多层次的反馈不断调整以逼近目标</li></ul></li></ul></li></ol><h2>实践</h2><ol><li><h4>因地制宜选择合适的敏捷实践</h4></li><li><h4>敏捷团队(SCRUM)</h4><ul><li><p><strong>产品负责人ProductOwner（PO）</strong>-产品经理/游戏策划/导演</p><ul><li><blockquote><p>负责产品，代表相关的利益</p></blockquote></li><li><p>提供愿景</p></li><li><p>代表利益相关人（如观众、Marketing、管理者等），对产品投资回报负责</p></li><li><p>确定产品发布计划</p></li><li><p>定义产品并确定优先级</p></li><li><p>验收迭代结果.并根据验收结果和需求变化刷新需求清单和优先级</p></li></ul></li><li><p><strong>SCRUM主管Scrum Master（SM）：</strong></p><ul><li><blockquote><p>确保Scurm正确使用和收益最大化，但是不做决定（不命令和控制Team）</p></blockquote></li><li><p>辅导团队正确应用敏捷实践</p></li><li><p>引导团队建立并遵守規则</p></li><li><p>保护团队不受打扰</p></li><li><p>推动解决团队遇到的障碍</p></li><li><p>激励团队</p></li></ul></li><li><p><strong>开发团队（Team）：</strong></p><ul><li><blockquote><p>负责自我管理开发产品的人组成的跨职能团队</p></blockquote></li><li><p>负责估计工作量并根据自身能力找出最佳方案完成任务且保证交付质重</p></li><li><p>向OP和利益相关人演示工作成果</p></li><li><p>团队自我管理、持续改进</p></li></ul></li></ul></li><li><h4>工作件</h4><ul><li><strong>产品Backlog（需求清单）</strong><ul><li>什么是产品Backlog<ul><li>经过优先级排序的动态刷新的产品需求清单，用来制定发布计划和迭代计划。</li></ul></li><li>产品Blocklog的好处<ul><li>通过需求的动态管理应对变化，避免浪费;</li><li>易于优先交付对用户价值高的需求。</li></ul></li><li>产品Blocklog关键要点<ul><li>清楚表述列表中每个需求任务对用户带来的价值，做为优先级排序的重要参考；</li><li>动态的需求管理而非"冻结"方式，PO持续地管理和及时刷新需求清单，在每轮迭代前，都要重新筛选出高优先级需求进入本轮迭代；</li><li>迭代的需求分析过程，而非一次性分析清楚所有需求（只对近期迭代要做的需求进行详细分析，其它需求停留在粗粒度）</li><li>[图片上传失败...(image-e6b495-1543726686826)]</li></ul></li></ul></li><li><strong>迭代Backlog</strong><ul><li>什么是迭代<ul><li>迭代Backlog是团队在一轮迭代中的"任务"（Task）清单，是团队的详细迭代开发计划；</li><li>当团队接收从产品Blocklog挑选出要在本轮迭代实现的需求时，召开团队迭代计划会议，将需求转化为具体的"任务"；</li><li>每项任务信息包括当前剩余工作量和贲任人。</li></ul></li><li>好处<ul><li>将需求分解成更细小的任务，利于对迭代内进度进行精确控制；</li><li>剩余工作量可用来实时跟踪团队当前进展。</li></ul></li><li>关键要点<ul><li>'任务"由团队成员自己分解和定义，而不是上级指派，支撑需求完成的所有工作都可以列为任务；</li><li>任务要落实到具体的贲任人；</li><li>任务粒度要小，工作量大于两天的任务要进一步分解；</li><li>用小时做为任务剩余工作量的估计单位，并每日重估计和刷新。</li></ul></li></ul></li><li><strong>完成标准</strong><ul><li>什么的完成标准<ul><li>基于"随时可向用户发布"的目标制定衡量团队工作是否已完成的标准，由团队和PO形成共识；</li></ul></li><li>好处<ul><li>共同协商的完成标准是团队的自我承诺，团队会更认真；</li><li>用于准确评估团队工作进展；</li><li>清晰和明确的完成标准保证了每次迭代是高质量的。</li></ul></li><li>关键要点<ul><li>团队自协商：团队根掮项目实际情况来定义完成标准，并严格遵守；</li><li>有层次：一般分为三个层次：Story级别，迭代级和发布级，每个级别都有各自的完成标准。</li></ul></li></ul></li></ul></li><li><h4>管理实践</h4><ul><li><strong>Sprint计划会议</strong><ul><li>什么是计划会议<ul><li>每轮迭代启动前，团队共同讨论本轮迭代详细开发计划的过程，输入是产品Backlog，输出是团队迭代Backlog</li><li>多团队迭代计划会议要分层召开<ol><li>版本迭代计划会议：将产品Backlog (需求）分配给团队；</li><li>团队迭代计划会议：将选取的产品Backlog需求转换成迭代Backlog〔任务），分配给团队成员；</li></ol></li><li>迭代计划会议内容：<ol><li>澄清需求、对"完成标准"达成一致</li><li>工作量估计、根据团队能力确定本轮迭代交付内容；</li><li>细化、分配迭代任务和初始工作计划。</li><li>[图片上传失败...(image-445853-1543726686826)]</li></ol></li></ul></li><li>好处<ul><li>通过充分讨论，使团队成员对任务和完成标准理解一致；</li><li>团队共同参与，促进团队成员更认真对待自己的承偌。</li></ul></li><li>要点<ul><li>充分参与：SM确保PO和Team充分参与讨论，达成理解一致；</li><li>相互承诺：Team承诺完成迭代Backlog中的需求并这到"完成标准”，PO承诺在短迭代周期不增加需求〔2-4周）；</li><li>确定内部任务：Team和PO办商把一些内部任务放入迭代中（例如重构、持续集成环境搭建4等），由PO考虑并与其他外部需求一起排序。</li></ul></li></ul></li><li><strong>每日站会</strong><ul><li>什么是站会<ul><li>每日工作前，团队成员的例行沟通机制，由SM组织，Team成员全体站立参加</li><li>聚焦在下面的三个主题：<ol><li>我昨天为本项目做了什么？</li><li>我计划今天为本项目做什么？</li><li>我需要什么帮助以更高效的工作？</li></ol></li></ul></li><li>好处<ul><li>增加团队凝聚力，产生积极的工作氛围</li><li>及时黍露风险和问题；</li><li>促进团队内成员的沟通和协调。</li></ul></li><li>要点<ul><li>准时开始：按计划会议制定的时间地点开会，形成团队成员的自然习惯；</li><li>高效会议：会议限时15分钟，每个人都保持站立，依次发言，不讨论与会议三个主题无关的事情〔如技术解决方案等）；</li><li>问题跟踪：SM应该记录下所有的问题并跟踪解决；</li></ul></li></ul></li><li><strong>迭代验收（评审会议）</strong><ul><li>由SM组织，PO和用户代表（外部或内部利益相关人）负责验收、Team负责演示</li></ul></li><li><strong>回顾会议</strong><ul><li>什么是回顾会议<ul><li>在每轮迭代结束后举行的会议，目的是分享好的经验和发现改逬点，促进团队不断进步；</li><li>围绕如下三个问题：<ol><li>本次迭代有哪些做得好</li><li>本次迭代我们在哪些方面还能做得更好</li><li>我们在下次迭代准备在哪些方面改进？</li></ol></li></ul></li><li>好处<ul><li>激励团队成员；</li><li>帮助团队挖掘优秀经验并继承;</li><li>避免团队犯重复的错误；</li><li>营造团队自主改进的氛围。</li></ul></li><li>要点<ul><li>会议气氛：Team全员参加，气氛宽松自由，畅所欲言，头脑风暴发现问题，共同分析根因；</li><li>关注重点：Team共同讨论优先级，将精力放在最需要的地方（关注几个改进就够了）；</li><li>会议结论要跟踪闭环：可以放入迭代Backlog中。</li></ul></li></ul></li><li><strong>可视化管理</strong><ul><li>项目跟踪<ul><li>To Do</li><li>Doing</li><li>Done</li><li>Finished</li></ul></li><li>故事看板[图片上传失败...(image-dd8ce4-1543726686826)]</li></ul></li></ul></li><li><h4>技术实践</h4></li></ol><h2>敏捷特点：简单、高效</h2><ul><li>所有人对项目的成功负责</li><li>所有人由需求驱动工作，需求一旦确定，就不应该修改了</li><li>所有人都需要跨领域的工作</li><li>持续交付、迭代前进</li><li>小步前进、持续改进</li></ul><hr><h1>首次实施敏捷的步骤</h1><ol><li>思想动员</li><li>差距分析</li><li>环境和工具准备</li><li>敏捷实践技能准备，技术能力准备</li><li>确定开发模型和拟应用实践</li><li>敏捷实施</li><li>回顾评估与调整改进</li><li>激励表彰</li><li>项目结束总结</li></ol>          </div><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC80NTQ2Ny8yMTk3OQ=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;@[TOC](敏捷开发指导思想)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="开发" scheme="https://myblong.zkb/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="思维" scheme="https://myblong.zkb/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>为什么现在越来越感觉恋爱越困难了</title>
    <link href="https://myblong.zkb/2019/07/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%81%8B%E7%88%B1%E8%B6%8A%E6%9D%A5%E8%B6%8A%E9%9A%BE/"/>
    <id>https://myblong.zkb/2019/07/21/为什么恋爱越来越难/</id>
    <published>2019-07-21T13:13:10.641Z</published>
    <updated>2019-07-24T14:28:33.412Z</updated>
    
    <content type="html"><![CDATA[<pre><code>@[TOC](为什么现在越来越感觉恋爱越困难了?)</code></pre><h1 id="起因"><a href="#起因" class="headerlink" title="起因?"></a>起因?</h1><p> 前两天，我和朋友聊天虚度无聊的时间。有一个朋友为感情的事愁眉不展，她说在生活的压力下，感觉自己变得难以心动，对一切都感到麻木。<br>我也思考起，自己和身边人的感情生活。确实，好像一切都变了，但不是变得难以心动，而是心动之后所面对的一连串现实问题，让我们望而却步了。<br><a id="more"></a></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>二十多岁的我们，为什么觉得谈恋爱好难</p><p>才想起，过去的我并不觉得恋爱是件难事。</p><p>在我年幼无知的时候，我拿着自己心爱的psp游戏机当礼物，自己半年的零花钱就没了，因为那天是她的生日。</p><p>之后的大部分时间里，每天吃方便面和包子馒头之类的当午饭，靠着同学的接济硬是撑了过去。那时候我并没有想太多，只是义无反顾地想让对方开心，再苦也值得。</p><p>高中毕业以后，她去了在北方的一个城市上学。而我留在了南方，离家不远的学校。有时候她会说：“想你了。可以来找我吗。”我回复一个笑容，然后迅速转移到下一个话题中。</p><p>我在想，如果还是那个时候我，一定会花光积蓄去找她吧。不知不觉，我已经不再会为爱情倾其所有。</p><p>而与此同时，似乎她也开始改变了。我们每天的对话，经常只有三句：“我起来了”，“上课去了”，“早点睡”。</p><p>从前，她事无大小总会跟我分享，但是后来她再也没谈起过她的生活。反倒是在朋友圈里，我才看见她参加的各样聚会，跟朋友在周边城市旅游，有时玩到半夜才回家。</p><p>但我们都没有因此而感到难过或不适，反而开始适应了彼此独立的生活，不再盲目地追求当年义无反顾的激情。</p><p>从前我们年轻气盛，认为恋爱大过天，什么阻碍都不放在眼里，只要彼此相爱就好。但是二十多岁了，我们逐渐各自独立，而我再也不敢这样感性地义无反顾下去。</p><p>因为我们都心知肚明，异地恋成功的概率太小，成本太高了。也许，这几年的感情，很快就只能是一段回忆了。</p><p>而那些曾经让人羡慕的校园模范情侣们，到了现在的年纪，好像也走不过这一遭。</p><p>曾经我们可能因为长相，因为性格，也可能是相互感觉不错，就能尝试走到一起。但现在，恋爱却多了很多前提。</p><p>工作是否稳定？</p><p>有房有车吗？</p><p>会不会经常分隔两地？</p><p>家庭环境如何？</p><p>双方父母怎么样？</p><p>在精打细算完一连串的问题之后，爱反而成为了最后才会思考的问题。<br>    我曾经遇到过十分喜欢的人，常常聊着天就会对着手机不自觉地笑出声。我们喜欢同样的歌曲和食物，喜欢同一座城市，还会幼稚地拍下身边有趣的东西发给对方，有着共同目标。</p><p>但我们都不敢轻易尝试开始，因为于我们而言，要在一起很容易，往后要面对的问题却很难。</p><p>同样刚毕业的我们，养活自己都已经很吃力，更不要说负担两个人的额外花销。更何况工作之余，已没有太多精力顾及另一个人。</p><p>朋友说：“我突然很害怕。害怕以后会迫不得已选择一个会给我良好生活、满足一切前提的人，但不是一个我真正喜欢的人。”</p><p>我也很害怕。我害怕自己无法给对方带来一个好的生活，只剩下我独自面对着现实带来的孤独和折磨。</p><p>似乎恋爱中的问题，已经让我们逐渐变得可怕。</p><p>比如当她们得知一个大学朋友，即将嫁给一个三十多岁的有钱有势的人时，身边人的第一反应是羡慕和恭贺，但却没有一个人问她是否喜欢对方。</p><p>在那一瞬间，她觉得自己“这么多年来的书都白读了”。因为在现实面前，我们都不经意变得肤浅起来。</p><p>我反复思考她所说的话，一直到凌晨四点都没睡着。</p><p>也许，我们真的过了只要努力一下就能在一起的年纪了，过去藏在校服和学习背后的东西，终究被扯了出来。</p><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC80NTQ2Ny8yMTk3OQ=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 -->]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;@[TOC](为什么现在越来越感觉恋爱越困难了?)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因?&quot;&gt;&lt;/a&gt;起因?&lt;/h1&gt;&lt;p&gt; 前两天，我和朋友聊天虚度无聊的时间。有一个朋友为感情的事愁眉不展，她说在生活的压力下，感觉自己变得难以心动，对一切都感到麻木。&lt;br&gt;我也思考起，自己和身边人的感情生活。确实，好像一切都变了，但不是变得难以心动，而是心动之后所面对的一连串现实问题，让我们望而却步了。&lt;br&gt;
    
    </summary>
    
    
      <category term="感想" scheme="https://myblong.zkb/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="随笔" scheme="https://myblong.zkb/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>国外mari直播讲解教学</title>
    <link href="https://myblong.zkb/2019/07/21/mari%E5%9B%BD%E5%A4%96/"/>
    <id>https://myblong.zkb/2019/07/21/mari国外/</id>
    <published>2019-07-21T02:19:58.689Z</published>
    <updated>2019-07-21T03:16:52.349Z</updated>
    
    <content type="html"><![CDATA[<p>**</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  在国内贴图制作软件被substance painter大部分占领的情况下，还有一款贴图制作软件没有被国内重视。相比substance painter,MARI可以输出高达精度的贴图纹理和多象限绘制的能力，同时兼顾游戏和影视绘制高精度纹理的需求，对硬件要求也更高。</p><p>**<br><a id="more"></a><br><div class="content"><div class="content-container layout-text-media pad-left" style="display: table;"><div class="media" style="float: left;"><div class="text-media"><div class="media-wrapper"><div class="media-container" style="max-width: 1201px;"><div class="media-shadow"><iframe class="media-frame video" autostart="false" frameborder="0" width="100%" height="100%" src="//player.bilibili.com/player.html?aid=59539298&cid=103731994&page=1" style="max-width: 720.6px; height: 405px; width: 720.6px;"></iframe></div><div class="credit"></div></div></div></div></div><div class="text" style="width: 40%; display: table-cell;"><div class="container" style="display: table-cell; width: auto;"><h2 class="date">March 2019</h2><h3>国外mari直播讲解教学</h3><p><a style="font-size:30px; color:#00FA9A;" href="https://www.bilibili.com/video/av59539298/" target="_blank">在线观看</a></p></div></div></div></div><!-- 来必力City版安装代码 --><div id="lv-container" data-id="city" data-uid="MTAyMC80NTQ2Ny8yMTk3OQ=="><script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') { return; }       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   })(document, 'script');</script><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript></div><!-- City版安装代码已完成 --></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;**&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  在国内贴图制作软件被substance painter大部分占领的情况下，还有一款贴图制作软件没有被国内重视。相比substance painter,MARI可以输出高达精度的贴图纹理和多象限绘制的能力，同时兼顾游戏和影视绘制高精度纹理的需求，对硬件要求也更高。&lt;/p&gt;
&lt;p&gt;**&lt;br&gt;
    
    </summary>
    
      <category term="mair相关" scheme="https://myblong.zkb/categories/mair%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="贴图" scheme="https://myblong.zkb/tags/%E8%B4%B4%E5%9B%BE/"/>
    
      <category term="mari" scheme="https://myblong.zkb/tags/mari/"/>
    
  </entry>
  
  <entry>
    <title>Photogrammetry-学习(4)</title>
    <link href="https://myblong.zkb/2019/07/21/share/photogrmmt(4)/"/>
    <id>https://myblong.zkb/2019/07/21/share/photogrmmt(4)/</id>
    <published>2019-07-21T01:22:13.982Z</published>
    <updated>2019-07-21T01:22:46.517Z</updated>
    
    <content type="html"><![CDATA[<p>Photogrammetry拍摄的基础<br><a id="more"></a><br><div class="article-entry" itemprop="articleBody">                        <h1 id="Agisoft-Photoscan-其他功能介绍"><a href="#Agisoft-Photoscan-其他功能介绍" class="headerlink"></a><center>Agisoft Photoscan 其他功能介绍</center></h1><a id="more"></a><h2 id="标记（marker）"><a href="#标记（marker）" class="headerlink"></a>标记（marker）</h2><h3 id="什么是标记？"><a href="#什么是标记？" class="headerlink"></a>什么是标记？</h3><blockquote><p>标记是一些特定标识图案</p></blockquote><h3 id="为什么使用标记？"><a href="#为什么使用标记？" class="headerlink"></a>为什么使用标记？</h3><blockquote><p>使用标记可以更好识别摄像机位置</p></blockquote><h3 id="如何生成标记"><a href="#如何生成标记" class="headerlink"></a>如何生成标记</h3><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/1.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/1.png" title="操作截图"></a></p><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/2.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/2.png" title="操作截图"></a></p><blockquote><p>参数说明</p><ul><li>Marker Type（标记类型）—— 使用默认即可</li><li>Center Point Radius（中心点半径） —— 根据实际环境填写大小</li><li>Target Per Page —— 每一页生成多少标记，建议用6，不浪费纸张</li></ul></blockquote><blockquote><p>确认参数之后点击确定<br>就会生成一个PDF文档</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/3.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/3.png" title="操作截图"></a></p><blockquote><p>打开PDF文档</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/4.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/4.png" title="操作截图"></a></p><blockquote><p>传说中的标记出现了<br>你可以将标记拿去打印<br>然后将标记裁剪下来<br>贴到相应的位置上</p></blockquote><h3 id="如何识别标记"><a href="#如何识别标记" class="headerlink"></a>如何识别标记</h3><blockquote><p>导入图片就可以选择Dectect Markers（检测标记）</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/5.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/5.png" title="操作截图"></a></p><blockquote><p>检测参数使用默认即可</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/6.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/6.png" title="操作截图"></a></p><blockquote><p>检测速度一般比较快</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/7.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/7.png" title="操作截图"></a></p><blockquote><p>检测完成之后就可以看到标记点</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/8.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/8.png" title="操作截图"></a></p><blockquote><p>标记点检测不全可能是因为照片模糊、亮度不够等原因造成<br>这样在进行Align Photos就会自动参考标记点去识别照相机的位置</p></blockquote><h2 id="遮罩蒙版（Mask）"><a href="#遮罩蒙版（Mask）" class="headerlink"></a>遮罩蒙版（Mask）</h2><h3 id="什么是遮罩？"><a href="#什么是遮罩？" class="headerlink"></a>什么是遮罩？</h3><blockquote><p>遮罩顾名思义和PS、AE的遮罩一致<br>用于抠出特定区域</p></blockquote><h3 id="为什么使用遮罩？"><a href="#为什么使用遮罩？" class="headerlink"></a>为什么使用遮罩？</h3><blockquote><p>使用遮罩可以限制识别区域和生成区域<br>加快生成效率<br>提高检测准确性</p></blockquote><h3 id="如何使用遮罩？"><a href="#如何使用遮罩？" class="headerlink"></a>如何使用遮罩？</h3><blockquote><p>Photoscan 提供了基础的抠图工具</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/9.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/9.png" title="操作截图"></a></p><blockquote><p>操作原理和PS一致<br>只是功能有点少<br>不大好用</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/10.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/10.png" title="操作截图"></a></p><blockquote><p>框出区域右键可以看到相应的快捷键操作</p></blockquote><h3 id="导入遮罩"><a href="#导入遮罩" class="headerlink"></a>导入遮罩</h3><blockquote><p>因为软件自带的抠图比较垃圾<br>所以软件提供了导入遮罩的方案</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/11.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/11.png" title="操作截图"></a></p><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/12.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/12.png" title="操作截图"></a></p><blockquote><p>除了Method 和 Filename Template<br>其他参数均用默认即可</p></blockquote><blockquote><p>Agisoft Photoscan 提供了四种遮罩方案</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/13.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/13.png" title="操作截图"></a></p><h4 id="From-Alpha"><a href="#From-Alpha" class="headerlink"></a>From Alpha</h4><blockquote><p>通过图片的Alpha通道导入遮罩<br>可以使用PS抠出遮罩保存到Alpha通道中<br>Photoscan识别图片Alpha通道完成通道导入</p></blockquote><h4 id="From-File"><a href="#From-File" class="headerlink"></a>From File</h4><blockquote><p>通过文件导入遮罩<br>这个需要制作出遮罩的黑白图</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/14.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/14.png" title="操作截图"></a></p><blockquote><p>使用这种方案需要注意Filename Template要使用宏定义{filename}来识别每一个文件名</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/15.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/15.png" title="操作截图"></a></p><h4 id="From-Background"><a href="#From-Background" class="headerlink"></a>From Background</h4><blockquote><p>通过背景生成遮罩<br>这个需要拍摄有背景和没有背景的图片<br>软件会自动匹配两者的区别来生成遮罩</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/16.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/16.png" title="操作截图"></a></p><blockquote><p>这种方案非常适合顶点拍摄<br>在统一环境当中<br>背景也是固定<br>只需要1张背景就可以为每张图片抠出相对准确的遮罩</p></blockquote><h4 id="From-Model"><a href="#From-Model" class="headerlink"></a>From Model</h4><blockquote><p>这个操纵需要生成的模型来抠图<br>但是抠模型只需要1次<br>根据抠出的模型可以自动匹配到每一张图片上<br>速度快，效果也非常好</p></blockquote><h3 id="遮罩操作"><a href="#遮罩操作" class="headerlink"></a>遮罩操作</h3><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/17.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-学习之路（四）/17.png" title="操作截图"></a></p><blockquote><p>使用了遮罩之后 Apply Mask to 选项就可以选择了<br>Key Point 限制识别的范围<br>Tie Point 限制生成的范围</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink"></a>总结</h2><blockquote><ul><li>标记可以让摄像机识别更精确</li><li>遮罩可以优化生成效果、生成更精确</li></ul></blockquote>          </div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Photogrammetry拍摄的基础&lt;br&gt;
    
    </summary>
    
      <category term="Photogrammetry" scheme="https://myblong.zkb/categories/Photogrammetry/"/>
    
    
      <category term="Photogrammetry" scheme="https://myblong.zkb/tags/Photogrammetry/"/>
    
      <category term="扫描" scheme="https://myblong.zkb/tags/%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>Photogrammetry-学习(3)</title>
    <link href="https://myblong.zkb/2019/07/16/share/photogrmmt(3)/"/>
    <id>https://myblong.zkb/2019/07/16/share/photogrmmt(3)/</id>
    <published>2019-07-16T14:20:46.132Z</published>
    <updated>2019-07-16T14:21:51.603Z</updated>
    
    <content type="html"><![CDATA[<p>Photogrammetry拍摄的基础<br><a id="more"></a><br><div class="article-inner">          <input type="hidden" class="isFancy">              <header class="article-header">              <h1 class="article-title" itemprop="name">      Photogrammetry 学习之路（3）    </h1>        </header>            <div class="article-info article-info-post">                                <div class="clearfix"></div>      </div>              <div class="article-entry" itemprop="articleBody">                        <h1 id="Photogrammetry软件操作后期基本流程"><a href="#Photogrammetry软件操作后期基本流程" class="headerlink"></a><center>Photogrammetry软件操作后期基本流程</center></h1><a id="more"></a><h2 id="Build-Mesh-（生成网格）"><a href="#Build-Mesh-（生成网格）" class="headerlink"></a>Build Mesh （生成网格）</h2><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" title="操作截图"></a></p><blockquote><p>参数说明</p><ul><li>Surface Type（表面类型) —— 使用默认的Arbitrary 3D</li><li>Source Data（源数据） —— 务必使用Dense Cloud 密集点云，稀疏点云数据太少，无法生成完整的模型</li><li>Face Count（面数） —— 通常都使用最高，确保模型的精细度，后期可以减面</li><li>Interpolation（差值） —— 使用默认或者选择Aggressive，目前我发现影响不大</li><li>Calculate vertex colors（计算顶点信息） —— 这个不勾选，生成模型就没有颜色</li></ul></blockquote><blockquote><p>参数调整之后即可点击OK 执行运算</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" title="操作截图"></a></p><blockquote><p>计算完毕之后可以看到模型了</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" title="操作截图"></a></p><blockquote><p>你可以点击这些按钮来切换模型的观察方案</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" title="操作截图"></a></p><blockquote><p>如果模型没有太大的问题就可以进行下一步</p></blockquote><h2 id="Build-Map-（生成贴图）"><a href="#Build-Map-（生成贴图）" class="headerlink"></a>Build Map （生成贴图）</h2><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" title="操作截图"></a></p><blockquote><p>参数说明</p><ul><li>Mapping Mode（映射类型) —— 选择默认的Generic方式，这里涉及的是UV的展开方式</li><li>Blending Mode（混合模式） —— 这里也是使用默认的Mosaic即可，当然也可以选择Average来柔化贴图</li><li>Texture Size/Count（贴图大小） —— 默认4K已经够大了</li><li>Enable Hole Filling（开启填充洞） —— 默认开启，用来优化模型的破洞</li><li>Enable Ghosting Filter（开启重像滤波器） —— 重像就是俗称的画面糊成一团，这可以可以优化贴图效果</li></ul></blockquote><blockquote><p>确认过参数之后就可以去生成贴图了</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" title="操作截图"></a></p><blockquote><p>生成贴图完毕之后 点击上面的按钮查看贴图生成的效果</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/7.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/7.png" title="操作截图"></a></p><blockquote><p>我觉得生成的纹理还是非常的不错的</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/8.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/8.png" title="操作截图"></a></p><h2 id="导出模型"><a href="#导出模型" class="headerlink"></a>导出模型</h2><blockquote><p>导出模型需要对模型右键 选择Export Model…</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/9.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/9.png" title="操作截图"></a></p><blockquote><p>选择保存的路径</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/10.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/10.png" title="操作截图"></a></p><blockquote><p>这里会弹出导出设置窗口</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/11.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/11.png" title="操作截图"></a></p><blockquote><p>参数功能就不一一赘述了，基本上关注一下导出的图片格式即可。<br>另外，比较可惜的是只支持OBJ格式</p></blockquote><h2 id="Maya查看导出的模型"><a href="#Maya查看导出的模型" class="headerlink"></a>Maya查看导出的模型</h2><blockquote><p>将模型导入Maya当中</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.picgz.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/12.png-waterMark" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.picgz.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/12.png-waterMark" title="操作截图"></a></p><blockquote><p>可以开启Flat Lighting 获取更好的观感<br>基本上完美还原了模型的细节，达到了真实可靠的效果</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.picgz.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/13.png-waterMark" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.picgz.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/13.png-waterMark" title="操作截图"></a></p><blockquote><p>从面数上也是挺多的</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.picgz.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/14.png-waterMark" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.picgz.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%BA%8C%EF%BC%89/14.png-waterMark" title="操作截图"></a></p><h1 id="总结"><a href="#总结" class="headerlink"></a>总结</h1><blockquote><p>Photogrammetry软件操作基本流程</p><ul><li>通过照片生成稀疏点云</li><li>通过稀疏点云计算Depth Map，生成密集点云</li><li>通过密集点云计算生成模型</li><li>生成贴图</li><li>导出模型和贴图</li></ul><p>这些操作不适用Agisoft Photoscan，其他照片扫描软件也是一致的。</p></blockquote><h1 id="后记"><a href="#后记" class="headerlink"></a>后记</h1><ul><li>针对扫描的流程，后面我会再出博文讲解，敬请期待。</li></ul>          </div>      </div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Photogrammetry拍摄的基础&lt;br&gt;
    
    </summary>
    
      <category term="Photogrammetry" scheme="https://myblong.zkb/categories/Photogrammetry/"/>
    
    
      <category term="Photogrammetry" scheme="https://myblong.zkb/tags/Photogrammetry/"/>
    
      <category term="扫描" scheme="https://myblong.zkb/tags/%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>Photogrammetry-学习(2)</title>
    <link href="https://myblong.zkb/2019/07/14/share/photogrmmt(2)/"/>
    <id>https://myblong.zkb/2019/07/14/share/photogrmmt(2)/</id>
    <published>2019-07-14T06:03:36.628Z</published>
    <updated>2019-07-14T06:07:10.067Z</updated>
    
    <content type="html"><![CDATA[<p>Photogrammetry拍摄的基础<br><a id="more"></a><br><div class="article-inner">          <input type="hidden" class="isFancy">              <header class="article-header">        </header>            <div class="article-info article-info-post">          </div>                <div class="clearfix"></div>      </div>              <div class="article-entry" itemprop="articleBody">                        <h1 id="Photogrammetry-拍照指南"><a href="#Photogrammetry-拍照指南" class="headerlink"></a><center>Photogrammetry 拍照指南</center></h1><a id="more"></a><h2 id="拍照设备"><a href="#拍照设备" class="headerlink"></a>拍照设备</h2><blockquote><p>Photogrammetry照片建模看重的是照片的成像质量<br>好的设备当然能够事半功倍<br>但是简单的手机设备也未尝不可</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%89%EF%BC%89/1.jpg" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%89%EF%BC%89/1.jpg" title="操作截图"></a></p><blockquote><p>我并不是专业的摄影师<br>对照相机的研究并不多<br>但是从目前我的接触来看<br>只要拍照质量过硬<br>手机不比相机差</p></blockquote><h2 id="拍照参数"><a href="#拍照参数" class="headerlink"></a>拍照参数</h2><blockquote><p>Photogrammetry 拍照和普通照相还是有几点不相同的</p><ul><li><strong>所有的设置都尽量不用自动</strong>（<strong>让图片保持一致</strong>）</li><li><strong>ISO要尽可能低</strong>（<strong>降低噪点</strong>）</li><li><strong>F-stop不能调太低</strong>（<strong>减少背景虚化</strong>）</li><li><strong>快门速度要尽可能的小</strong>（<strong>降低重影效果</strong>）</li><li><strong>聚焦清晰</strong>（<strong>聚焦模糊会影响贴图效果</strong>）</li><li><strong>白平衡要一致</strong>（<strong>通常采用贴近真实的风格</strong>）</li></ul></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%89%EF%BC%89/2.jpg" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%89%EF%BC%89/2.jpg" title="操作截图"></a></p><h2 id="单一物体拍照方案"><a href="#单一物体拍照方案" class="headerlink"></a>单一物体拍照方案</h2><h3 id="以物体为中心"><a href="#以物体为中心" class="headerlink"></a>以物体为中心</h3><blockquote><p>摄像机围绕物体进行拍照<br>适用于比较大的物体</p></blockquote><h4 id="注意事项"><a href="#注意事项" class="headerlink"></a><strong>注意事项</strong></h4><ul><li>移动之后一定要稳定摄像机再进行拍摄</li><li>移动的弧度不要太大，每张图片的间隔最好相互覆盖50%以上</li><li>拍摄时最好采用多角度（上中下角度）</li></ul><h4 id="优点"><a href="#优点" class="headerlink"></a>优点</h4><ul><li>结合背景，摄像机位置识别相对准确</li><li>拍照灵活</li><li>成本低</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink"></a>缺点</h4><ul><li>拍照繁琐消耗体力（可以用三脚架固定但是麻烦）</li><li>自然光难以调控，光照不均匀</li><li>抠图困难，需要后期处理</li></ul><h3 id="以摄像机为中心"><a href="#以摄像机为中心" class="headerlink"></a>以摄像机为中心</h3><blockquote><p>摄像机固定拍摄旋转物体<br>适用于比较小的物体</p></blockquote><h4 id="注意事项（以物体为中心的注意事项在这里也一致）"><a href="#注意事项（以物体为中心的注意事项在这里也一致）" class="headerlink"></a><strong>注意事项</strong>（以物体为中心的注意事项在这里也一致）</h4><ul><li>需要配备三角架固定摄像机</li><li>需要配备关照环境均匀布光</li><li>需要配备转台转动物体</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink"></a>优点</h4><ul><li>拍照方便简单</li><li>光线统一均匀</li><li>背景统一方便生成遮罩</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink"></a>缺点</h4><ul><li>以物体识别为主，容易造成识别混乱</li><li>需要设备配合，成本较高</li></ul><h2 id="环境拍照方案"><a href="#环境拍照方案" class="headerlink"></a>环境拍照方案</h2><blockquote><p>大环境拍摄难以采用固定摄像机的方案<br>固定摄像机会导致图片扭曲以及细节不足的问题<br>拍照注意可以参照以物体为中心的拍照方案</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink"></a>总结</h2><ul><li>Photogrammetry的拍照参数要设置好，切勿使用自动参数</li><li>拍照的时候追求稳定清晰，亮度也要适中</li><li>拍照要均匀围绕物体</li></ul>      </div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Photogrammetry拍摄的基础&lt;br&gt;
    
    </summary>
    
      <category term="Photogrammetry" scheme="https://myblong.zkb/categories/Photogrammetry/"/>
    
    
      <category term="Photogrammetry" scheme="https://myblong.zkb/tags/Photogrammetry/"/>
    
      <category term="扫描" scheme="https://myblong.zkb/tags/%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>Photogrammetry-学习(1)</title>
    <link href="https://myblong.zkb/2019/06/30/share/photogrmmt(1)/"/>
    <id>https://myblong.zkb/2019/06/30/share/photogrmmt(1)/</id>
    <published>2019-06-30T05:58:32.907Z</published>
    <updated>2019-06-30T06:06:47.483Z</updated>
    
    <content type="html"><![CDATA[<p>Photogrammetry基础介绍<br><a id="more"></a><br><div class="article-entry" itemprop="articleBody">                        <h1 id="Photogrammetry-入坑前言"><a href="#Photogrammetry-入坑前言" class="headerlink"></a><center>Photogrammetry 入坑前言</center></h1><a id="more"></a><p>&emsp;&emsp;最近研究照片扫描技术，并且推荐了一款软件<strong>3DF Zephyr</strong>，但是这款软件的教程太少了，经过我的调查，我发现Agisoft Photoscan是目前比较成熟的软件，就这样我就进了Photogrammetry的大坑。</p><p>&emsp;&emsp; Photogrammetry是什么呢？正如上面的软件介绍一样，它是一种通过一系列的照片还原三维模型的技术。</p><hr><p>&emsp;&emsp; 那Photogrammetry有什么优点，对比目前市场上的其他扫描技术又有什么优势和劣势呢？</p><blockquote><p>Photogrammetry的优点</p><ul><li>通过照片生成模型和纹理，细节丰富到令人发指，模型细腻</li><li>生成速度快，操作相对简单</li><li>制作成本低，甚至可以用手机拍照完成流程</li><li>支持扫描大型物体，甚至是航拍地图</li></ul></blockquote><blockquote><p>Photogrammetry的缺点</p><ul><li>无法处理颜色大规模统一的物体（<strong>影响图片识别</strong>）</li><li>无法处理随着角度变化的强烈高光（<strong>影响图片识别</strong>）</li><li>无法处理透明材质（<strong>影响图片识别</strong>）</li><li>无法处理多重相似的图案（<strong>影响图片识别</strong>）</li><li>细小的物体难以生成高质量的模型</li><li>不均匀的光线分布会影响扫描的效果</li><li>拍摄多角度扫描素材比较繁琐</li></ul></blockquote><blockquote><p>Photogrammetry与激光扫描的技术对比</p><ul><li>激光扫描的模型精度与Photogrammetry不相上下</li><li>激光扫描可以解决Photogrammetry因为图片识别而无法扫描的硬伤</li><li>高规格的激光扫描方可识别颜色，成本很高</li><li>激光扫描难以胜任大型物体扫描，特别是航拍</li></ul></blockquote><hr><h1 id="软件下载"><a href="#软件下载" class="headerlink"></a>软件下载</h1><p><strong>3DF Zephyr</strong></p><p>链接: <a href="https://pan.baidu.com/s/1Rz66Ui1VNWtKZeVh55scmg" target="_blank" rel="noopener">https://pan.baidu.com/s/1Rz66Ui1VNWtKZeVh55scmg</a> 密码: xnwn</p><p><strong>Agisoft Photoscan</strong></p><p>链接: <a href="https://pan.baidu.com/s/1eZlWmDIxRNGhM0ZVnpWAQQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1eZlWmDIxRNGhM0ZVnpWAQQ</a> 密码: g3ne</p><hr><h1 id="Photogrammetry软件操作前期基本流程"><a href="#Photogrammetry软件操作前期基本流程" class="headerlink"></a>Photogrammetry软件操作前期基本流程</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink"></a><strong>软件安装</strong></h2><blockquote><p>打开软件安装包，直接安装。然后将破解文件覆盖快捷方式的启动程序。</p></blockquote><h3 id="启动程序即可看到软件界面"><a href="#启动程序即可看到软件界面" class="headerlink"></a>启动程序即可看到软件界面</h3><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/1.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/1.png" title="操作截图"></a></p><h3 id="正式使用之前务必先打开首选项"><a href="#正式使用之前务必先打开首选项" class="headerlink"></a>正式使用之前务必先打开首选项</h3><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/2.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/2.png" title="操作截图"></a></p><h3 id="首选项这里可以修改语言模式"><a href="#首选项这里可以修改语言模式" class="headerlink"></a>首选项这里可以修改语言模式</h3><blockquote><p>不习惯英语的可以修改为中文，在下还是依然使用英文。</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/3.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/3.png" title="操作截图"></a></p><h3 id="另外去到GPU的标签-务必开启CUDA显卡加速"><a href="#另外去到GPU的标签-务必开启CUDA显卡加速" class="headerlink"></a>另外去到GPU的标签 务必开启CUDA显卡加速</h3><blockquote><p>开启之后你就能体验飞一样的感觉（GPU运算速度是CPU的好几倍）<br></p></blockquote><blockquote><p>原谅我的垃圾手提电脑，N卡940M太低端无法识别</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/4.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/4.png" title="操作截图"></a></p><hr><h1 id="基本流程"><a href="#基本流程" class="headerlink"></a><strong>基本流程</strong></h1><h2 id="点击打开workflow"><a href="#点击打开workflow" class="headerlink"></a><strong>点击打开workflow</strong></h2><blockquote><p>截图上的操作就是Photogrammetry的基本流程<br></p></blockquote><blockquote><p>我们需要一步一步去完成操作<br></p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/5.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/5.png" title="操作截图"></a></p><h2 id="Align-Photos-对齐照片"><a href="#Align-Photos-对齐照片" class="headerlink"></a><strong>Align Photos (对齐照片)</strong></h2><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/6.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/6.png" title="操作截图"></a></p><blockquote><p>这里有几个参数需要注意</p><ul><li>Acurray（识别精度） —— 不建议太高，太高会很慢。我一般选择Medium</li><li>Generic Preselection（常用预选） —— 对图片序列识别进行优化，通常都勾选</li><li>Key Point Limit（关键点上限）—— 建议为0，就是不设上限</li><li>Tie Point Limit（点云上限） —— 同样建议为0，就是不设上限</li><li>Adapt Camera model fitting（适应摄像机的位置）—— 一般都要勾选，特别是应用蒙版的情况</li></ul></blockquote><blockquote><p>设置完成即可运行操作</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/7.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/7.png" title="操作截图"></a></p><blockquote><p>识别完成之后会生成sparse cloud（稀疏点云）<br></p></blockquote><blockquote><p>比较成功的识别结果（图片识别规整)</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/8.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/8.png" title="操作截图"></a></p><blockquote><p>比较失败的识别结果（图片错位)</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/9.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/9.png" title="操作截图"></a></p><blockquote><p>图片错位的原因</p><ul><li>Align Photos 的识别精度太低了或太高了</li><li>照片存在模糊、距离不一、角度偏移等问题</li><li>物体上存在Photogrammetry无法解决的硬伤</li></ul></blockquote><h2 id="Build-Dense-Cloud-（生成密集点云）"><a href="#Build-Dense-Cloud-（生成密集点云）" class="headerlink"></a><strong>Build Dense Cloud （生成密集点云）</strong></h2><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/10.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/10.png" title="操作截图"></a></p><blockquote><p>参数说明</p><ul><li>Quality（质量） —— 不建议太高，太高会很慢。我一般选择Medium</li><li>Depth filtering（深度过滤） —— 一般为Aggressive或者默认参数</li><li>Calculate point colors（计算顶点颜色） —— 这个务必要勾选，否则生成模型没有颜色</li></ul></blockquote><blockquote><p>只要一开始的 sparse cloud 没有太大问题，那么密集点云的步骤也比较顺利<br>这个步骤需要比较长的运算时间</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/11.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/11.png" title="操作截图"></a></p><blockquote><p>在生成的过程中软件会生成Depth Map来重新构建照片的深度，从而奠定立体生成的基础（这个需要中断生成步骤才可以看到）</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/13.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/13.png" title="操作截图"></a></p><blockquote><p>根据流程生成完毕是这样子的（这个效果是建立在Sparse Cloud的基础上的）</p></blockquote><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/12.png" title="操作截图" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Photogrammetry/Photogrammetry-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/12.png" title="操作截图"></a></p><hr><h1 id="总结"><a href="#总结" class="headerlink"></a>总结</h1><blockquote><p>Photogrammetry软件操作前期流程</p><ul><li>通过照片生成稀疏点云</li><li>通过稀疏点云计算Depth Map，生成密集点云</li></ul></blockquote>          </div>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Photogrammetry基础介绍&lt;br&gt;
    
    </summary>
    
      <category term="Photogrammetry" scheme="https://myblong.zkb/categories/Photogrammetry/"/>
    
    
      <category term="Photogrammetry" scheme="https://myblong.zkb/tags/Photogrammetry/"/>
    
      <category term="扫描" scheme="https://myblong.zkb/tags/%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python系列（三）之高级特性</title>
    <link href="https://myblong.zkb/2019/06/22/share/python%E5%AD%A6%E4%B9%A0_3/"/>
    <id>https://myblong.zkb/2019/06/22/share/python学习_3/</id>
    <published>2019-06-22T13:15:53.824Z</published>
    <updated>2019-06-22T13:15:53.916Z</updated>
    
    <content type="html"><![CDATA[<p>切片操作（slice），即从list（tuple是一种特殊的list）中获取部分元素。<br><a id="more"></a><br><div class="                col-lg-8 col-lg-offset-2                col-md-10 col-md-offset-1                post-container">                <h2 id="1-切片"><a class="anchorjs-link " href="#1-切片" aria-label="Anchor link for: 1 切片" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1. 切片</h2><div id="toc" class="toc-article toc-fixed">        <strong class="toc-title">Contents</strong>                  <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-切片"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1. 切片</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-迭代"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2. 迭代</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#21-迭代的概念"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">2.1 迭代的概念</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#22-迭代的使用"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">2.2 迭代的使用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#221-dict的迭代"><span class="toc-nav-number">2.2.1.</span> <span class="toc-nav-text">2.2.1 dict的迭代</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#222-字符串的迭代"><span class="toc-nav-number">2.2.2.</span> <span class="toc-nav-text">2.2.2 字符串的迭代</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#223-迭代的索引"><span class="toc-nav-number">2.2.3.</span> <span class="toc-nav-text">2.2.3 迭代的索引</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#224-多变量迭代"><span class="toc-nav-number">2.2.4.</span> <span class="toc-nav-text">2.2.4 多变量迭代</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-列表生成式"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3. 列表生成式</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-生成器"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4. 生成器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#41-直接创建generator"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">4.1 直接创建generator</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#42-通过函数方式创建"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">4.2 通过函数方式创建</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-迭代器"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5. 迭代器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#51-可迭代对象"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">5.1 可迭代对象</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#52-迭代器"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">5.2 迭代器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#推荐文章"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">推荐文章</span></a></li></ol>                </div><p>切片操作（slice），即从list（tuple是一种特殊的list）中获取部分元素。</p><ul><li>L[m,n]表示从L[m]~L[n-1]的list。</li><li>L[:n]表示从L[0]~L[n-1]的list。</li><li>L[m:]表示从L[m]~L[len(L)-1]。</li><li>L[-m:]表示倒数m个数的list。</li><li>L[m:n:k]表示从L[m:n]list中每k个取一个数组成一个新的list。</li><li>L[::k]表示从L中每k个取一个组成新的list。</li><li>tuple也是一种list（不可变的list），使用切片操作的结果仍为tuple。</li></ul><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"><span class="comment">#切片操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:]</span><br><span class="line">[<span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">-2</span>:<span class="number">-1</span>]</span><br><span class="line">[<span class="string">'Bob'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义0-99的list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = list(range(<span class="number">100</span>))</span><br><span class="line"><span class="comment">#前10个数每两个取一个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment">#所有数，每5个取一个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[::<span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#tuple的切片操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)[:<span class="number">3</span>]</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#字符串切片操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFG'</span>[:<span class="number">3</span>]</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABCDEFG'</span>[::<span class="number">2</span>]</span><br><span class="line"><span class="string">'ACEG'</span></span><br></pre></td></tr></tbody></table></div></figure><h2 id="2-迭代"><a class="anchorjs-link " href="#2-迭代" aria-label="Anchor link for: 2 迭代" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2. 迭代</h2><h3 id="21-迭代的概念"><a class="anchorjs-link " href="#21-迭代的概念" aria-label="Anchor link for: 21 迭代的概念" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.1 迭代的概念</h3><p>迭代：在某类对象的集合中通过遍历的方法来获取元素，对元素执行某项操作。</p><p>Python中的可迭代对象有：list，tuple，dict，str等，包括可迭代的自定义类型。</p><p>判断一类对象是否可迭代，可以通过collections模块的Iterable类型判断。例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></tbody></table></div></figure><h3 id="22-迭代的使用"><a class="anchorjs-link " href="#22-迭代的使用" aria-label="Anchor link for: 22 迭代的使用" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.2 迭代的使用</h3><p>在Python中，迭代是通过<code>for ... in</code>来完成的。</p><h4 id="221-dict的迭代"><a class="anchorjs-link " href="#221-dict的迭代" aria-label="Anchor link for: 221 dict的迭代" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.2.1 dict的迭代</h4><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = {<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line"><span class="meta">... </span>    print(key)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br></pre></td></tr></tbody></table></div></figure><ul><li>dict默认迭代的是key，<code>for key in d</code>。</li><li>可以使用<code>for value in d.values()</code>来迭代value。</li><li>可以用<code>for k, v in d.items()</code>来迭代key和value。</li></ul><h4 id="222-字符串的迭代"><a class="anchorjs-link " href="#222-字符串的迭代" aria-label="Anchor link for: 222 字符串的迭代" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.2.2 字符串的迭代</h4><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'ABC'</span>:</span><br><span class="line"><span class="meta">... </span>    print(ch)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></tbody></table></div></figure><h4 id="223-迭代的索引"><a class="anchorjs-link " href="#223-迭代的索引" aria-label="Anchor link for: 223 迭代的索引" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.2.3 迭代的索引</h4><p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, value)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br></pre></td></tr></tbody></table></div></figure><h4 id="224-多变量迭代"><a class="anchorjs-link " href="#224-多变量迭代" aria-label="Anchor link for: 224 多变量迭代" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.2.4 多变量迭代</h4><p>在for中，同时引用多个变量。例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:</span><br><span class="line"><span class="meta">... </span>    print(x, y)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br></pre></td></tr></tbody></table></div></figure><h2 id="3-列表生成式"><a class="anchorjs-link " href="#3-列表生成式" aria-label="Anchor link for: 3 列表生成式" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3. 列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><p>一般是通过<code>for … in</code>和<code>range</code>来生成list。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></tbody></table></div></figure><p><strong>for循环中加if判断</strong></p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></tbody></table></div></figure><p><strong>多层循环</strong></p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br></pre></td></tr></tbody></table></div></figure><p><strong>多变量循环</strong></p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = {<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> }</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</span><br></pre></td></tr></tbody></table></div></figure><p>可以使用内建的<code>isinstance</code>函数可以判断一个变量是不是字符串。</p><h2 id="4-生成器"><a class="anchorjs-link " href="#4-生成器" aria-label="Anchor link for: 4 生成器" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4. 生成器</h2><p>在Python中，一边循环一边计算的机制，称为生成器：generator。生成器不必创建完整的list，可以在循环中不断推算出后续的元素，从而可以在获取所需元素的同时节省存储空间。</p><h3 id="41-直接创建generator"><a class="anchorjs-link " href="#41-直接创建generator" aria-label="Anchor link for: 41 直接创建generator" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.1 直接创建generator</h3><p>创建generator即把列表生成式的<code>[]</code>改成<code>()</code>。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br></pre></td></tr></tbody></table></div></figure><p>一般通过<code>for循环</code>来获取generator的元素，也可以使用<code>next(g)</code>来获取下一个元素。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="comment">#通过for循环获取元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">#通过next()获取元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></div></figure><h3 id="42-通过函数方式创建"><a class="anchorjs-link " href="#42-通过函数方式创建" aria-label="Anchor link for: 42 通过函数方式创建" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.2 通过函数方式创建</h3><p>通过<code>yield</code>关键字将一个函数变成<code>generator</code>。例如：</p><p>函数的定义：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br></pre></td></tr></tbody></table></div></figure><p>生成器的定义：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br></pre></td></tr></tbody></table></div></figure><p>两者的差别在于生成器将函数的<code>print(b)</code>改为<code>yield b</code>。<code>yield</code>可以翻译为<code>生成</code>，即基于某次计算生成某个元素，而不是提前存储了该元素。</p><p>函数式的<code>generator</code>一般采用<code>for</code>循环来获取元素，也可以通过<code>next()</code>来获取下一个元素的值，例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):</span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></tbody></table></div></figure><p>如果要获取<code>return</code>的内容，可以捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = fib(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        x = next(g)</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'g:'</span>, x)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Generator return value:'</span>, e.value)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line">g: <span class="number">1</span></span><br><span class="line">g: <span class="number">1</span></span><br><span class="line">g: <span class="number">2</span></span><br><span class="line">g: <span class="number">3</span></span><br><span class="line">g: <span class="number">5</span></span><br><span class="line">g: <span class="number">8</span></span><br><span class="line">Generator <span class="keyword">return</span> value: done</span><br></pre></td></tr></tbody></table></div></figure><h2 id="5-迭代器"><a class="anchorjs-link " href="#5-迭代器" aria-label="Anchor link for: 5 迭代器" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>5. 迭代器</h2><h3 id="51-可迭代对象"><a class="anchorjs-link " href="#51-可迭代对象" aria-label="Anchor link for: 51 可迭代对象" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>5.1 可迭代对象</h3><p>可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。主要有：</p><ul><li>集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等</li><li><code>generator</code>，包括生成器和带<code>yield</code>的generator function</li></ul><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance({}, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">100</span>, Iterable)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></tbody></table></div></figure><h3 id="52-迭代器"><a class="anchorjs-link " href="#52-迭代器" aria-label="Anchor link for: 52 迭代器" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>5.2 迭代器</h3><p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。</p><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>是<code>Iterable</code>，而不是<code>Iterator</code>。</p><p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance({}, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></tbody></table></div></figure><p>可以通过<code>iter()</code>函数将<code>Iterable</code>转换成<code>Iterator</code>。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter([]), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></tbody></table></div></figure><p>Python的<code>Iterator</code>对象表示的是一个数据流，可以是无限大的数据流，例如全体自然数。</p><ul><li><code>Iterator</code>的元素是基于计算的，可以理解为惰性的、动态的、长度未知的（元素个数可能无限）。</li><li><code>list</code>、<code>dict</code>、<code>str</code>的元素是基于存储的，可以理解为静态的、长度已知的（元素个数有限）。</li></ul></div>                                                                            </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;切片操作（slice），即从list（tuple是一种特殊的list）中获取部分元素。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://myblong.zkb/categories/python/"/>
    
    
      <category term="python" scheme="https://myblong.zkb/tags/python/"/>
    
      <category term="python基础" scheme="https://myblong.zkb/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>pyqt基础开发一</title>
    <link href="https://myblong.zkb/2019/06/16/share/pyqt%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/"/>
    <id>https://myblong.zkb/2019/06/16/share/pyqt基础开发/</id>
    <published>2019-06-16T14:07:00.316Z</published>
    <updated>2019-06-16T14:14:00.198Z</updated>
    
    <content type="html"><![CDATA[<p>## 简单对比原生开发和Qt开发的不同之处。<br>  Qt开发似乎需要写更多的代码，需要更复杂的操作。<br>  其实不慌，当你学习了 QtDesigner 之后，你就会开始觉得原生开发是多么地不人性化了:-)<br><a id="more"></a><br><div class="article-inner">          <input type="hidden" class="isFancy">                <div class="article-info article-info-post">                          <div class="article-meta">                    </div>                <div class="clearfix"></div>      </div>              <div class="article-entry" itemprop="articleBody">                        <h1 id="QtDesigner-介绍-amp-入门"><a href="#QtDesigner-介绍-amp-入门" class="headerlink"></a>QtDesigner 介绍&amp;入门</h1><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink"></a>前言</h2><blockquote><p>&emsp;&emsp;简单对比原生开发和Qt开发的不同之处。<br>&emsp;&emsp;Qt开发似乎需要写更多的代码，需要更复杂的操作。<br>&emsp;&emsp;其实不慌，当你学习了 QtDesigner 之后，你就会开始觉得原生开发是多么地不人性化了:-)</p></blockquote><h2 id="什么是-QtDesigner"><a href="#什么是-QtDesigner" class="headerlink"></a>什么是 QtDesigner</h2><blockquote><p>&emsp;&emsp;QtDesigner是由官方推出并维护的，图形化界面制作窗口的工具。<br>&emsp;&emsp;如果你接触过 Android 开发 以及 Web前端的 Bootstrap 可视化，都可以感受到这种拖拽开发的快速之处。<br>&emsp;&emsp;当然目前我觉得图形化拖拽做得最好的还是QtDsigner。<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/01.gif" title="Android Studio 图形化界面开发" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/01.gif" title="Android Studio 图形化界面开发"></a><br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/02.gif" title="Bootstrap 可视化开发" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/02.gif" title="Bootstrap 可视化开发"></a></p></blockquote><!-- ![alt](https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/02.gif) --><h2 id="安装Qt-Designer"><a href="#安装Qt-Designer" class="headerlink"></a>安装Qt Designer</h2><blockquote><p>&emsp;&emsp;安装Qt Designer 的方法有很多</p><ul><li>安装官方提供的 Qt Creator 开发软件</li><li>安装任意 Qt Python包</li><li>安装Maya自带Qt Designer</li></ul></blockquote><h3 id="Qt-Creator"><a href="#Qt-Creator" class="headerlink"></a>Qt Creator</h3><blockquote><p>&emsp;&emsp;Qt Creator是一个IDE，是针对Qt优化的 C++ 开发平台，里面内置了许多Qt开发相关的工具，Qt Designer 就在其中。<br>&emsp;&emsp;具体安装流程参考网上的<a href="https://blog.csdn.net/qq_23473839/article/details/80523318" target="_blank" rel="noopener">文章</a></p></blockquote><h3 id="Qt-Python-包"><a href="#Qt-Python-包" class="headerlink"></a>Qt Python 包</h3><blockquote><p>&emsp;&emsp;安装任意Qt Python 包<br>&emsp;&emsp;只要安装好 Python 环境，可以打开cmd控制台，通过 pip 安装相关的 Pyhton 包<br>&emsp;&emsp;另外需要注意的是，如果安装旧版本的 PyQt4 ，已经无法直接通过 pip install 安装，需要手动到对应的网站下载 wheel 进行安装。<a href="https://blog.csdn.net/wlanye/article/details/83855668" target="_blank" rel="noopener">参考</a><br>&emsp;&emsp;当你安装好之后，你可以在 Pyhton 的 site-packages 目录下找到 PyQt4 文件夹<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/03.png" title="PyQt4 文件夹" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/03.png" title="PyQt4 文件夹"></a><br>&emsp;&emsp;打开目录可以找到 designer.exe 程序<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/04.png" title="designer.exe 程序" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/04.png" title="designer.exe 程序"></a></p></blockquote><h3 id="Maya-自带-Qt-Designer"><a href="#Maya-自带-Qt-Designer" class="headerlink"></a>Maya 自带 Qt Designer</h3><blockquote><p>&emsp;&emsp;打开 maya 的安装路径<br>&emsp;&emsp;可以在 bin 目录下找到 designer.exe 程序<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/05.png" title="designer.exe 程序" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/05.png" title="designer.exe 程序"></a><br>&emsp;&emsp;maya中的 designer.exe 程序打开可能会报错<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/06.png" title="报错" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/06.png" title="报错"></a><br>&emsp;&emsp;网上可以找到解决方案 <a href="https://www.cnblogs.com/ibingshan/p/9784087.html" target="_blank" rel="noopener">参考</a></p></blockquote><h2 id="初始-Qt-Designer"><a href="#初始-Qt-Designer" class="headerlink"></a>初始 Qt Designer</h2><blockquote><p>&emsp;&emsp;启动 Qt Designer 之后可以看到如下画面<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/07.png" title="Qt Designer 初始界面" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/07.png" title="Qt Designer 初始界面"></a><br>&emsp;&emsp;我们可以选择 widget 创建出窗口<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/08.png" title="创建 Widget 窗口" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/08.png" title="创建 Widget 窗口"></a><br>&emsp;&emsp;下面就可以拖拽左侧的组件到窗口上<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/09.gif" title="创建排列UI" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/09.gif" title="创建排列UI"></a><br>&emsp;&emsp;注：按住 ctrl 拖拽可以快速复制组件<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/10.png" title="布局按钮" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/10.png" title="布局按钮"></a><br>&emsp;&emsp;窗口上方的这些按钮可以改变窗口的布局，也可以从左侧拖拽相关的布局到窗口上。<br>&emsp;&emsp;Qt 自带的布局我上期教程也有提及过，最常用的有</p><ul><li>QHBoxLayout - 横向布局</li><li>QVBoxLayout - 竖向布局</li><li>QGridLayout - 网格布局</li></ul><p>&emsp;&emsp;通过这些布局就可以让组件等分排布，从而减少UI的凌乱感<br>&emsp;&emsp;横向布局 就是将布局内部的组件 横向等分排列<br>&emsp;&emsp;竖向布局 也顾名思义<br>&emsp;&emsp;<br>&emsp;&emsp;网格布局 则需要给定网格的位置对网格进行等分，也可以让组件占用多个网格，或者空出多余的网格。<br>&emsp;&emsp;通过网格布局可以排列出下面这种形态组件状态。<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/11.gif" title="网格布局" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/11.gif" title="网格布局"></a></p></blockquote><blockquote><p>&emsp;&emsp;在 Qt Designer 的右侧有属性编辑器以及对象查看器的大纲视图<br>&emsp;&emsp;属性编辑器可以编辑UI的属性，不过很多时候，是用代码来动态修改这些属性。<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/12.png" title="XML文件" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/12.png" title="XML文件"></a><br>&emsp;&emsp;通常情况下，objectName比较重要，因为后面代码调用的时候会通过 objectName 的属性来调用。<br>&emsp;&emsp;当你创建完成 UI 之后，就可以 ctrl+s 保存当前编辑的文件<br>&emsp;&emsp;Qt Designer 会输出一个后缀为 ui 的文件<br>&emsp;&emsp;如果你用文本编辑器打开 ui 文件，你会发现其实它是个XML文件<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/13.png" title="XML文件" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/13.png" title="XML文件"></a><br>&emsp;&emsp;因此当你熟悉了它XML输出的格式也可以通过魔改XML里面的内容来生成出特殊的组件文件。</p></blockquote><h2 id="在-maya-中调用-ui-文件"><a href="#在-maya-中调用-ui-文件" class="headerlink"></a>在 maya 中调用 ui 文件</h2><blockquote><p>&emsp;&emsp;默认情况下 ui 文件只是 XML 配置而已，是无法直接使用的。<br>&emsp;&emsp;不过也有多种情况让ui文件运行起来</p><ul><li>通过 python Qt 框架下的 pyuic5 或者 pyside2-uic 将 ui 文件编译为 python 文件</li><li>导入uic相关的python模块，通过读取 ui 文件的内容动态编译python代码</li><li>直接用 maya 内置的命令编译 ui 文件</li></ul></blockquote><h3 id="编译-ui-文件"><a href="#编译-ui-文件" class="headerlink"></a>编译 ui 文件</h3><blockquote><p>&emsp;&emsp;在maya安装目录的bin目录下有 pyside2-uic 程序  - <a href="1547a34f.html#环境变量-扩展">如何使用CMD命令我在第三期教程做了补充</a><br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/14.png" title="pyside2-uic 程序" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/14.png" title="pyside2-uic 程序"></a></p></blockquote><blockquote><p>&emsp;&emsp;这个程序要运行起来需要添加 .exe 后缀，而且在我的电脑上运行会出现报错。<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/21.png" title="pyside2-uic编译程序" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/21.png" title="pyside2-uic编译程序"></a><br>&emsp;&emsp;注: bin 目录下还有 uic.exe 程序是可用的，只不过编译出来的文件是 C++ 代码 <em>(:з」∠)</em></p></blockquote><blockquote><p>&emsp;&emsp;因此如果maya内置uic编译器不可用的话，可以通过安装相关的 Python Qt 库，可以在相关路径下找到编译程序<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/15.png" title="PyQt 包下的 编译程序" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/15.png" title="PyQt 包下的 编译程序"></a><br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/20.png" title="pyside2-uic编译程序" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/20.png" title="pyside2-uic编译程序"></a><br>&emsp;&emsp;通过命令行调用这个程序后面加上 -h 可以显示出使用方法<br><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/16.png" title="pyside2-uic 程序 帮助" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/16.png" title="pyside2-uic 程序 帮助"></a></p></blockquote><figure class="highlight bash resize0" data-lang="bash"><div style="position: absolute; top: 14385.4px; right: 2em;"><button type="button" class="btn btn-primary" id="copyBtn0" data-clipboard-action="copy" data-clipboard-target=".code0">复制</button></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code code0"><pre><span class="line">pyside2-uic C:\Users\Administrator\Desktop\img\test.ui -o C:\Users\Administrator\Desktop\img\test_ui.py</span><br></pre></td></tr></tbody></table><style>.highlight.resize0::before{width:1072px}</style></figure><blockquote><p>&emsp;&emsp;基本写法就是： <code>程序名 ui文件 -o 输出的python文件</code><br>&emsp;&emsp;这样就可以将 ui 文件 编译为 python 文件，不过需要注意的是 PyQt的编译 maya 需要 改为 PySide 的库进行导入<br>&emsp;&emsp;编译好的文件可以通过继承的方法来调用。</p></blockquote><figure class="highlight python resize1" data-lang="python"><div style="position: absolute; top: 14649.4px; right: 2em;"><button type="button" class="btn btn-primary" id="copyBtn1" data-clipboard-action="copy" data-clipboard-target=".code1">复制</button></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code code1"><pre><span class="line"><span class="comment"># 编译好的 ui 文件 导入其中的类(类名和UI文件当中的最外层的组件的objectName一致)</span></span><br><span class="line"><span class="keyword">from</span> test_ui <span class="keyword">import</span> Ui_Form</span><br><span class="line"><span class="keyword">from</span> PySide2.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PySide2.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PySide2.QtCore <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">window</span><span class="params">(Ui_Form,QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 执行 QWidget 的 __init__ </span></span><br><span class="line">        super(window,self).__init__()</span><br><span class="line">        <span class="comment"># 从 Ui_Form 继承的方法，可以直接将ui生成出来</span></span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(<span class="string">u"用 pyside2-uic 程序编译python 继承出来的窗口"</span>)</span><br><span class="line">        self.show()</span><br><span class="line">        </span><br><span class="line">win = window()</span><br></pre></td></tr></tbody></table><style>.highlight.resize1::before{width:1072px}</style></figure><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/17.png" title="代码执行效果" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/17.png" title="代码执行效果"></a></p><h3 id="直接用代码编译"><a href="#直接用代码编译" class="headerlink"></a>直接用代码编译</h3><blockquote><p>&emsp;&emsp;此处可以参考我以前看教程写的<a href="ef451c1b.html">文章</a></p></blockquote><figure class="highlight python resize2" data-lang="python"><div style="position: absolute; top: 15854.5px; right: 2em;"><button type="button" class="btn btn-primary" id="copyBtn2" data-clipboard-action="copy" data-clipboard-target=".code2">复制</button></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code code2"><pre><span class="line"><span class="keyword">from</span> PySide2.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PySide2.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PySide2.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pyside2uic</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> xml</span><br><span class="line"><span class="keyword">from</span> cStringIO <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadUiType</span><span class="params">(uiFile)</span>:</span></span><br><span class="line">    <span class="comment"># 通过XML模块读取ui文件</span></span><br><span class="line">    parsed = xml.parse(uiFile)</span><br><span class="line">    <span class="comment"># 获取Qt相关的组件名</span></span><br><span class="line">    widget_class = parsed.find(<span class="string">'widget'</span>).get(<span class="string">'class'</span>)</span><br><span class="line">    <span class="comment"># 获取类名</span></span><br><span class="line">    form_class = parsed.find(<span class="string">'class'</span>).text</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(uiFile, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        o = StringIO()</span><br><span class="line">        frame = {}</span><br><span class="line">        <span class="comment"># 通过 pyside2uic 编译 ui 文件</span></span><br><span class="line">        pyside2uic.compileUi(f, o, indent=<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># o.getvalue() 这里的数据就是 UI 文件编程python的代码，通过 exec 执行这个字符串</span></span><br><span class="line">        pyc = compile(o.getvalue(), <span class="string">'&lt;string&gt;'</span>, <span class="string">'exec'</span>)</span><br><span class="line">        <span class="keyword">exec</span> pyc <span class="keyword">in</span> frame</span><br><span class="line"></span><br><span class="line">        <span class="comment"># form_class 就是ui文件编译出来的类名</span></span><br><span class="line">        form_class = frame[<span class="string">'Ui_%s'</span>%form_class]</span><br><span class="line">        <span class="comment"># base_class 就是Qt的窗口组件 eval 获取出 变量</span></span><br><span class="line">        base_class = eval(<span class="string">'%s'</span>%widget_class)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> form_class, base_class</span><br><span class="line"></span><br><span class="line">UI_PATH = <span class="string">r"C:\Users\Administrator\Desktop\test.ui"</span></span><br><span class="line">form_class , base_class = loadUiType(UI_PATH)</span><br><span class="line"><span class="comment"># 这里的继承其实和上面编译好的 ui 文件的代码是一样的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface</span><span class="params">(base_class,form_class)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Interface,self).__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.setWindowTitle(<span class="string">u"用 pyside2uic 编译出来的窗口"</span>)</span><br><span class="line">        self.show()</span><br><span class="line">ui = Interface()</span><br></pre></td></tr></tbody></table><style>.highlight.resize2::before{width:1072px}</style></figure><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/18.png" title="代码执行效果" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/18.png" title="代码执行效果"></a></p><blockquote><p>&emsp;&emsp;通过这个函数可以直接将ui文件在编译到内存当中，这样每次修改ui文件就不需要再额外用 exe 工具进行编译了<br>&emsp;&emsp;当然缺点就是没有了ui编译好的python文件，组件的自动代码提示也就没有了，所以开发的时候还需要对着 Qt Designer 的名字，有点麻烦。</p></blockquote><blockquote><p>&emsp;&emsp;额外补充一下，上述的方案只适用于 PySide ，如果使用PyQt实现的话，代码会简略很多。</p></blockquote><figure class="highlight python resize3" data-lang="python"><div style="position: absolute; top: 17696.1px; right: 2em;"><button type="button" class="btn btn-primary" id="copyBtn3" data-clipboard-action="copy" data-clipboard-target=".code3">复制</button></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code code3"><pre><span class="line"><span class="keyword">from</span> PyQt4 <span class="keyword">import</span> uic</span><br><span class="line">form_class , base_class = uic.loadUiType(UI_PATH)</span><br></pre></td></tr></tbody></table><style>.highlight.resize3::before{width:1072px}</style></figure><h3 id="maya-内置命令编译UI文件"><a href="#maya-内置命令编译UI文件" class="headerlink"></a>maya 内置命令编译UI文件</h3><blockquote><p>&emsp;&emsp;maya的 mel 有 <a href="http://help.autodesk.com/cloudhelp/2018/ENU/Maya-Tech-Docs/Commands/loadUI.html" target="_blank" rel="noopener">loadUi</a> 命令，可以直接将ui文件路径读取 生成出 maya 的窗口</p></blockquote><figure class="highlight mel resize4" data-lang="mel"><div style="position: absolute; top: 17971px; right: 2em;"><button type="button" class="btn btn-primary" id="melBtn4">MEL原生样式</button><button type="button" class="btn btn-primary" id="copyBtn4" data-clipboard-action="copy" data-clipboard-target=".code4">复制</button></div><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code code4"><pre><span class="line"><span class="mel_command">string</span> $dialog1 = <span class="mel_string">`loadUI -f "C:\\Users\\Administrator\\Desktop\\test.ui"`</span>;</span><br><span class="line"><span class="mel_keyword">window</span> -e -title <span class="mel_string">"通过 mel 编译的 ui 文件"</span> $dialog1;</span><br><span class="line"><span class="mel_keyword">showWindow</span> $dialog1;</span><br></pre></td></tr></tbody></table><style>.highlight.resize4::before{width:1072px}</style></figure><p><a data-fancybox-href="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/19.png" title="代码执行效果" rel="fancy-group" class="fancy-ctn fancybox"><img src="https://blog-image-1257068932.cos.ap-guangzhou.myqcloud.com/Python%20QT/session2/19.png" title="代码执行效果"></a></p><h2 id="总结"><a href="#总结" class="headerlink"></a>总结</h2><blockquote><p>&emsp;&emsp;Qt designer 的使用并不复杂，虽然Qt Designer 支持信号槽等比较高级的开发内容，但是由于很难通过 XML 来实现所需要的触发效果，因此难当大任。<br>&emsp;&emsp;我目前使用 Qt designer 也是为了快速创建出UI界面，毕竟手打界面的效率还是比较低的，特别是还要考虑各种固定组件的布局位置。<br>&emsp;&emsp;后续的组件触发大都是放在 python 代码当中完成。<br>&emsp;&emsp;如果想要更进一步了解 Qt Designer 的开发，可以参考B站上的教程</p><ul><li><a href="https://www.bilibili.com/video/av36210854" target="_blank" rel="noopener">Python桌面系统开发 PYQT5全套教程</a></li></ul></blockquote>          </div>      </div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;## 简单对比原生开发和Qt开发的不同之处。&lt;br&gt;  Qt开发似乎需要写更多的代码，需要更复杂的操作。&lt;br&gt;  其实不慌，当你学习了 QtDesigner 之后，你就会开始觉得原生开发是多么地不人性化了:-)&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://myblong.zkb/categories/python/"/>
    
    
      <category term="python" scheme="https://myblong.zkb/tags/python/"/>
    
      <category term="python基础" scheme="https://myblong.zkb/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于WorldMachine基础介绍</title>
    <link href="https://myblong.zkb/2019/06/15/share/WorldMachine%E5%9F%BA%E7%A1%80/"/>
    <id>https://myblong.zkb/2019/06/15/share/WorldMachine基础/</id>
    <published>2019-06-15T15:02:16.949Z</published>
    <updated>2019-06-15T16:01:19.753Z</updated>
    
    <content type="html"><![CDATA[<p>WorldMachine基础介绍<br><a id="more"></a><br><article class="article-content"><p>大家好，这里带来的是用<a href="" title="" target="_blank" data-original-title="关于WorldMachine的文章">WorldMachine</a>+制造出非常有装逼效果的地形，适合做一些daily render的小练习。</p><p>*这个教程非常初级，仅供参考。</p><p><a href="" title="" target="_blank" data-original-title="查看更多关于WorldMachine的文章">WorldMachine</a>是一款专业的三维山脉和地形生成软件，它可以生动模拟大自然的真实地形，并给您一个交互编辑的环境，让您快速又轻松地创建专业地形，创建完成以后，您可以将模型，贴图，高度图导出到您的三维软件或者游戏引<span id="pos_placeholder" style="width: 0px;height: 0px;margin: 0px;padding: 0px"></span>擎当中进一步使用。</p><p>由于我们是使用<a href="" title="" target="_blank" data-original-title="查看更多关于WorldMachine的文章">WorldMachine</a>与C4D进行结合，主要讲<a href="" title="" target="_blank" data-original-title="查看更多关于WorldMachine的文章">WorldMachine</a>与其他三维软件的结合中的一些常用工具，不会涉及到很多的关于真实地形的创建，更多的是讲一些关于艺术化、风格化的地形的创建。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007155882.png" title="" rel="external" data-original-title="（1）" target="_blank"><br><img title=" 1" alt=" 1" class="aligncenter size-full wp-image-3207" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007155882.png"></a></p><p><a href="https://www.btbat.com/tag/worldmachine" title="" target="_blank" data-original-title="查看更多关于WorldMachine的文章">WorldMachine</a>的工作流程依靠节点化的编辑，对基础的地形进行一些合成、修改的操作来达到自己想要的效果，如果对于Substance Designer，阿诺德这种用节点化编辑的比较熟悉的就可以很快的上手<a href="https://www.btbat.com/tag/worldmachine" title="" target="_blank" data-original-title="查">WorldMachine</a>。</p><p>接下来我们进入正题，开始用WorldMachine创造出一个属于你自己的地形。</p><p>首先，我们点击Generator（生成器）来创建一些基础的地形，这些基础的地形可以相互之间以上一个节点输出参数加上下一个节点的参数进行生成。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007400859.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 2" alt="学习使我快乐！ - 2" class="aligncenter size-full wp-image-3211 okmemo-dragging" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007400859.png"></a></p><p>这里我先创建了一个基础的Radial Grad，就是一个山丘的样子，再创建一个Advanced Perlin，将Radial Grad节点的输出与shaping guide相链接，相当于在平地上放置一座山峰。</p><p><a class="okmemo-tmp-unselect" href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007464568.png" rel="external" title="" data-original-title="）" target="_blank"><img title=" 3" alt=" - 3" class="aligncenter size-full wp-image-3213 okmemo-dragging" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007464568.png"></a><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007464527.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 4" alt="学习使我快乐！ - 4" class="aligncenter size-full wp-image-3212" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007464527.png"></a> <a href="http://img0.btbat.com/wp-content/uploads/2017/12/201712200746461.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 5" alt="学习使我快乐！ - 5" class="aligncenter size-full wp-image-3214" src="http://img0.btbat.com/wp-content/uploads/2017/12/201712200746461.png"></a></p><p>我们可以点击当前节点并点击lock preview锁定当前节点的预览，可以双击节点点开更加详细的参数的控制，在advanced perlin节点里，scale控制山体的形态，style控制山体梯度模式，octaves控制山体梯度等级。在radial grad节点里，radius控制突起的范围，type控制山体种类，生成器类的参数基本都类似，具体参数就不做过多讲解了，可以自行调整看看效果。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007504530.png" rel="external" class="fancybox" title="" data-original-title="）" target="_blank"><img title="学习使我快乐！ - 6" alt="学习使我快乐！ - 6" class="aligncenter size-full wp-image-3217" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007504530.png"></a> <a href="http://img0.btbat.com/wp-content/uploads/2017/12/201712200750114.png" rel="external" class="fancybox" title="" data-original-title="）" target="_blank"><img title="学习使我快乐！ - 7" alt="学习使我快乐！ - 7" class="aligncenter size-full wp-image-3216" src="http://img0.btbat.com/wp-content/uploads/2017/12/201712200750114.png"></a> <a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007501053.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 8" alt="地形！学习使我快乐！ - 8" class="aligncenter size-full wp-image-3215" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122007501053.png"></a></p><p>接下来我们创建一个voroni节点，并调整voroni节点的scale，将其缩小，产生更多的细节。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008013461.png" title="" rel="external" data-original-title="1）" target="_blank"><br></a> <a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008042199.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 9" alt="学习使我快乐！ - 9" class="aligncenter size-full wp-image-3220" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008042199.png"></a></p><p>我们在combiner选项里面创建一个combiner节点，将advanced perlin节点和voroni节点进行混合，调整combiner节点的method方法改成add，将两个节点进行添加模式。</p><p>&nbsp;</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008075137.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 10" alt="学习使我快乐！ - 10" class="aligncenter size-full wp-image-3221" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008075137.png"></a></p><p>接下来在nature节点里添加erosion（侵蚀，风化）节点将erosion节点的duration（持续时间）rock hardness （石化程度）sediment carrya mount（泥沙沉积量）进行调整，并可以点击上方绿色按钮进行地形的生成运算，点击上方绿色按钮左侧3D view可以进行3D的预览。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008233013.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 11" alt="学习使我快乐！ - 11" class="aligncenter size-full wp-image-3224" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008233013.png"></a></p><p>接下来，我们复制一层erosion节点，将两个erosion节点连在一起，减少rock hardness、提高sediment carry amount，提高duration，再次进行计算，提高地面平滑，增加山峰细节。<a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008304584.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 12" alt="学习使我快乐！ - 12" class="aligncenter size-full wp-image-3229" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008304584.png"></a></p><p>我们可以点击3D view上面的A|B进行计算前后的效果预览。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008340027.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 13" alt="学习使我快乐！ - 13" class="aligncenter size-full wp-image-3230" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008340027.png"></a></p><p>目前基础地形的创建就到此完毕，用基础的几个节点创建了一个山峰的地形，是不是很简单呢~</p><p>那么我们开始进行上色吧~</p><p>在selector（选择器）创建一个slope(斜率）节点，将erosion的primary输出到slope节点将erosion的wear map（磨损）输出到slope的mask，调整阈值，可以输出成山脉的树叶纹理。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008443330.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 14" alt="学习使我快乐！ - 14" class="aligncenter size-full wp-image-3234 okmemo-dragging" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008443330.png"></a><a href="http://img0.btbat.com/wp-content/uploads/2017/12/201712200844302.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 15" alt="学习使我快乐！ - 15" class="aligncenter size-full wp-image-3233" src="http://img0.btbat.com/wp-content/uploads/2017/12/201712200844302.png"></a></p><p>接下来我们在macros（宏）点击左边的打开，找到basic coverage，这个是系统预设好的上色的宏命令，或者也可以用converter里的colorizer节点，但是不推荐，这样就生成了山脉树叶纹理的颜色了，或者也可以吧erosion直接连到basic coverage，可以出来不同的效果，看个人喜好。可以改变rock和erosion的颜色，来出来不同的效果。上色部分就就基本上完成了。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008500641.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 16" alt="学习使我快乐！ - 16" class="aligncenter size-full wp-image-3236" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122008500641.png"></a></p><p>接下来就是导出部分。</p><p>在output里面依次创建mesh output、height output、bitmap output，再在converter里面创建normal-map maker并创建一个bitmap output。</p><p>将erosion连接到height output &nbsp;输出黑白的置换图，输出到meshkey输出obj格式的mesh模型，还可以新建一个overlay view去预览最后的成品，将basic coverage连接到overlay的颜色通道 erosion连接到overlay就可以看到自己做的成品啦，当然之前要先build一下。</p><p>normal-map maker+bitmap可以输出基于地形的法线贴图。</p><p>然后basic coverage+bitmap就是输出颜色贴图了~~</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009004320.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 17" alt="学习使我快乐！ - 17" class="aligncenter size-full wp-image-3238" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009004320.png"></a></p><p>然后设置一下目录~然后就可以准备输出了。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009180681.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 18" alt="学习使我快乐！ - 18" class="aligncenter size-full wp-image-3244" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009180681.png"></a> <a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009180738.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 19" alt="学习使我快乐！ - 19" class="aligncenter size-full wp-image-3245" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009180738.png"></a> <a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009180736.png" rel="external" class="fancybox" title="" data-original-title="）" target="_blank"><img title="学习使我快乐！ - 20" alt="学习使我快乐！ - 20" class="aligncenter size-full wp-image-3246" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009180736.png"></a></p><p>点击上面的world extents，可以修改地形的总体大小与容差高度，主要的是右边的是resolution控制输出的地形和贴图的精度，当然越大效果越精细，但是生成的时间就越长。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009205191.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 21" alt="学习使我快乐！ - 21" class="aligncenter size-full wp-image-3247" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009205191.png"></a></p><p>一切设置完毕之后就可以点击build，然后静待生成，点击export即可导出到设置的文件夹了。</p><p><a href="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009241691.png" rel="external" class="fancybox" title="" data-original-title="" target="_blank"><img title="学习使我快乐！ - 22" alt="学习使我快乐！ - 22" class="aligncenter size-full wp-image-3249" src="http://img0.btbat.com/wp-content/uploads/2017/12/2017122009241691.png"></a></p><p>~~简单的流程就这样~十分基础的教学，下次我会讲一下怎么贴材质到地形。</p><p>补一张2K的完成图。</p>         </article></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WorldMachine基础介绍&lt;br&gt;
    
    </summary>
    
      <category term="WorldMachine" scheme="https://myblong.zkb/categories/WorldMachine/"/>
    
    
      <category term="WorldMachine" scheme="https://myblong.zkb/tags/WorldMachine/"/>
    
      <category term="基础" scheme="https://myblong.zkb/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python系列（二）之Python函数</title>
    <link href="https://myblong.zkb/2019/06/14/python%E5%AD%A6%E4%B9%A0_2/"/>
    <id>https://myblong.zkb/2019/06/14/python学习_2/</id>
    <published>2019-06-14T15:28:18.166Z</published>
    <updated>2019-06-14T15:31:04.028Z</updated>
    
    <content type="html"><![CDATA[<p>使用pycharm给玛雅写python<br><a id="more"></a><br><div id="toc" class="toc-article toc-fixed">        <strong class="toc-title">Contents</strong>                  <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-内置函数"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1. 内置函数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#11-数据类型转换函数"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1.1 数据类型转换函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12-函数引用"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">1.2 函数引用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-定义函数"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2. 定义函数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#21-函数定义"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">2.1 函数定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#22-空函数"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">2.2 空函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#23-参数检查"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">2.3 参数检查</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#24-多返回值"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">2.4 多返回值</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-函数的参数"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3. 函数的参数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#31-位置参数"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">3.1 位置参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#32-默认参数"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">3.2 默认参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#33-可变参数"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">3.3 可变参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#34-关键字参数"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">3.4 关键字参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#35-命名关键字参数"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">3.5 命名关键字参数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#36-参数组合"><span class="toc-nav-number">3.6.</span> <span class="toc-nav-text">3.6 参数组合</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-递归函数"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4. 递归函数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#41-递归函数的定义"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">4.1 递归函数的定义</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#42-栈溢出问题"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">4.2 栈溢出问题</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#43-尾递归"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">4.3 尾递归</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#推荐文章"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">推荐文章</span></a></li></ol>                </div><div class="                col-lg-8 col-lg-offset-2                col-md-10 col-md-offset-1                post-container">                <h2 id="1-内置函数"><a class="anchorjs-link " href="#1-内置函数" aria-label="Anchor link for: 1 内置函数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1. 内置函数</h2><p>python的内置参数详见以下链接，也可以通过help(function_name)来查看具体函数的使用帮助。</p><p><a href="http://docs.python.org/3/library/functions.html#abs" target="_blank" rel="noopener">http://docs.python.org/3/library/functions.html#abs</a></p><div class="table-responsive"><table class="table"><thead><tr><th></th><th>Built-in Functions</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><a href="https://docs.python.org/3/library/functions.html#abs" target="_blank" rel="noopener"><code>abs()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-dict" target="_blank" rel="noopener"><code>dict()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#help" target="_blank" rel="noopener"><code>help()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#setattr" target="_blank" rel="noopener"><code>setattr()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#all" target="_blank" rel="noopener"><code>all()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#hex" target="_blank" rel="noopener"><code>hex()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#slice" target="_blank" rel="noopener"><code>slice()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#any" target="_blank" rel="noopener"><code>any()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#id" target="_blank" rel="noopener"><code>id()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#object" target="_blank" rel="noopener"><code>object()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#ascii" target="_blank" rel="noopener"><code>ascii()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#oct" target="_blank" rel="noopener"><code>oct()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#staticmethod" target="_blank" rel="noopener"><code>staticmethod()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#bin" target="_blank" rel="noopener"><code>bin()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><code>int()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-str" target="_blank" rel="noopener"><code>str()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><code>bool()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#ord" target="_blank" rel="noopener"><code>ord()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#sum" target="_blank" rel="noopener"><code>sum()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#func-bytearray" target="_blank" rel="noopener"><code>bytearray()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#filter" target="_blank" rel="noopener"><code>filter()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#pow" target="_blank" rel="noopener"><code>pow()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#super" target="_blank" rel="noopener"><code>super()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#func-bytes" target="_blank" rel="noopener"><code>bytes()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#iter" target="_blank" rel="noopener"><code>iter()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-tuple" target="_blank" rel="noopener"><code>tuple()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#callable" target="_blank" rel="noopener"><code>callable()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#format" target="_blank" rel="noopener"><code>format()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#property" target="_blank" rel="noopener"><code>property()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#type" target="_blank" rel="noopener"><code>type()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#chr" target="_blank" rel="noopener"><code>chr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-frozenset" target="_blank" rel="noopener"><code>frozenset()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-list" target="_blank" rel="noopener"><code>list()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-range" target="_blank" rel="noopener"><code>range()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#vars" target="_blank" rel="noopener"><code>vars()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#classmethod" target="_blank" rel="noopener"><code>classmethod()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#getattr" target="_blank" rel="noopener"><code>getattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#locals" target="_blank" rel="noopener"><code>locals()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#globals" target="_blank" rel="noopener"><code>globals()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#reversed" target="_blank" rel="noopener"><code>reversed()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#complex" target="_blank" rel="noopener"><code>complex()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#hasattr" target="_blank" rel="noopener"><code>hasattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#round" target="_blank" rel="noopener"><code>round()</code></a></td><td></td></tr><tr><td><a href="https://docs.python.org/3/library/functions.html#delattr" target="_blank" rel="noopener"><code>delattr()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-memoryview" target="_blank" rel="noopener"><code>memoryview()</code></a></td><td><a href="https://docs.python.org/3/library/functions.html#func-set" target="_blank" rel="noopener"><code>set()</code></a></td><td></td></tr></tbody></table></div><p>调用函数需要知道函数名和参数，如果传入的参数不对，会报<code>TypeError</code>的错误并且给出错误信息。</p><h3 id="11-数据类型转换函数"><a class="anchorjs-link " href="#11-数据类型转换函数" aria-label="Anchor link for: 11 数据类型转换函数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1.1 数据类型转换函数</h3><p>&#8203;  数据类型转换函数可以对数据类型进行转换，例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'123'</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">12.34</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="string">'12.34'</span>)</span><br><span class="line"><span class="number">12.34</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">1.23</span>)</span><br><span class="line"><span class="string">'1.23'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">100</span>)</span><br><span class="line"><span class="string">'100'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></tbody></table></div></figure><h3 id="12-函数引用"><a class="anchorjs-link " href="#12-函数引用" aria-label="Anchor link for: 12 函数引用" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1.2 函数引用</h3><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = abs <span class="comment"># 变量a指向abs函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">-1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></div></figure><h2 id="2-定义函数"><a class="anchorjs-link " href="#2-定义函数" aria-label="Anchor link for: 2 定义函数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2. 定义函数</h2><h3 id="21-函数定义"><a class="anchorjs-link " href="#21-函数定义" aria-label="Anchor link for: 21 函数定义" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.1 函数定义</h3><p>&#8203;  在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<code>return None</code>可以简写为<code>return</code>。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></tbody></table></div></figure><h3 id="22-空函数"><a class="anchorjs-link " href="#22-空函数" aria-label="Anchor link for: 22 空函数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.2 空函数</h3><p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></div></figure><p><code>pass</code>语句主要用来暂时让程序运行不报错，待后续再补充函数内容。同理，<code>pass</code>还可以用在其他语句里，比如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></div></figure><h3 id="23-参数检查"><a class="anchorjs-link " href="#23-参数检查" aria-label="Anchor link for: 23 参数检查" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.3 参数检查</h3><p>&#8203;  调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出<code>TypeError</code>。如果要对参数类型进行检查，可以使用内置函数<code>isinstance()</code>实现。例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></tbody></table></div></figure><h3 id="24-多返回值"><a class="anchorjs-link " href="#24-多返回值" aria-label="Anchor link for: 24 多返回值" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.4 多返回值</h3><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br></pre></td></tr></tbody></table></div></figure><p>&#8203;  实际上python的多返回值是一个tuple。只不过按位置依次赋值。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多返回值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(x, y)</span><br><span class="line"><span class="number">151.96152422706632</span> <span class="number">70.0</span></span><br><span class="line"><span class="comment">#返回值为tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r)</span><br><span class="line">(<span class="number">151.96152422706632</span>, <span class="number">70.0</span>)</span><br></pre></td></tr></tbody></table></div></figure><h2 id="3-函数的参数"><a class="anchorjs-link " href="#3-函数的参数" aria-label="Anchor link for: 3 函数的参数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3. 函数的参数</h2><p>&#8203;  定义函数的时候，把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值，而函数内部的复杂逻辑被封装起来，调用者无需了解。</p><h3 id="31-位置参数"><a class="anchorjs-link " href="#31-位置参数" aria-label="Anchor link for: 31 位置参数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1 位置参数</h3><p>&#8203;  位置参数，即传入的参数有位置顺序区分。例如以下的<code>x</code>和<code>n</code>根据位置不同，接收对应位置的传入参数。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></tbody></table></div></figure><h3 id="32-默认参数"><a class="anchorjs-link " href="#32-默认参数" aria-label="Anchor link for: 32 默认参数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.2 默认参数</h3><p>&#8203;  默认参数，即对某个参数设置默认值，如果没有传入该参数则使用默认值，如果有传入该参数则使用传入值。</p><ul><li>必须参数在前，默认参数在后</li></ul><ul><li>一般将变化小的参数设置为默认参数，变化大的设置为必选参数</li></ul><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="comment">#函数调用   </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">125</span></span><br></pre></td></tr></tbody></table></div></figure><p>有多个默认参数时，可以按顺序提供默认参数，也可以指定默认参数的参数名传值而不按参数顺序。例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enroll</span><span class="params">(name, gender, age=<span class="number">6</span>, city=<span class="string">'Beijing'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name)</span><br><span class="line">    print(<span class="string">'gender:'</span>, gender)</span><br><span class="line">    print(<span class="string">'age:'</span>, age)</span><br><span class="line">    print(<span class="string">'city:'</span>, city)</span><br><span class="line"><span class="comment">#按顺序提供默认参数，即7表示age的值   </span></span><br><span class="line">enroll(<span class="string">'Bob'</span>, <span class="string">'M'</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment">#按参数名提供默认参数，即city值，而没有age的值</span></span><br><span class="line">enroll(<span class="string">'Adam'</span>, <span class="string">'M'</span>, city=<span class="string">'Tianjin'</span>)</span><br></pre></td></tr></tbody></table></div></figure><p><strong>注意事项</strong>：默认参数必须指向不可变对象，例如整数，字符串，<code>None</code>等。不能指向可变对象，例如list。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#错误示例，默认参数为可变对象list</span></span><br><span class="line">add_end(L=[]):</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="comment">#每次调用都会在list中添加元素  </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>, <span class="string">'END'</span>]</span><br></pre></td></tr></tbody></table></div></figure><p>以上例子中，Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p><p>可改为指向<code>None</code>这个不可变对象来避免该问题。例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认参数指向不可变对象None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="comment">#每次调用恢复原默认值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>]</span><br></pre></td></tr></tbody></table></div></figure><h3 id="33-可变参数"><a class="anchorjs-link " href="#33-可变参数" aria-label="Anchor link for: 33 可变参数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.3 可变参数</h3><p>可变参数，即待传入的参数的个数是可变的，定义时在参数前面加个<code>*</code>，例如<code>*number</code>。可变参数在函数调用时实际上是一个tuple。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义可变参数 *number</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="comment">#函数调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment">#已存在list待传入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>])</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="comment">#通过list方式出传入可变参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></tbody></table></div></figure><h3 id="34-关键字参数"><a class="anchorjs-link " href="#34-关键字参数" aria-label="Anchor link for: 34 关键字参数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.4 关键字参数</h3><p>关键字参数，即可以传入0个或任意个含参数名的参数，关键字参数在函数调用时实际上是一个dict。</p><p>关键参数定义时在参数前面加<code>**</code>，例如<code>**kw</code>。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line"><span class="comment">#传入必选参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Michael'</span>, <span class="number">30</span>)</span><br><span class="line">name: Michael age: <span class="number">30</span> other: {}</span><br><span class="line"><span class="comment">#传入可选的关键字参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">name: Adam age: <span class="number">45</span> other: {<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>}</span><br><span class="line"><span class="comment">#使用dict方式传入关键字参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extra = {<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</span><br><span class="line">name: Jack age: <span class="number">24</span> other: {<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>}</span><br></pre></td></tr></tbody></table></div></figure><p>通过dict方式传入实际上是传入一份拷贝，函数参数的改变并不会影响到函数外原dict的值。</p><h3 id="35-命名关键字参数"><a class="anchorjs-link " href="#35-命名关键字参数" aria-label="Anchor link for: 35 命名关键字参数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.5 命名关键字参数</h3><p>通过对关键字参数命名的方式限制只能传入指定名字的关键字参数，而不能传入其他参数。命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义命名关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"><span class="comment">#命名关键字参数的调用    </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br></pre></td></tr></tbody></table></div></figure><p>命名关键字参数必须传入参数名，如果没有传入参数名，调用将报错。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, <span class="string">'Beijing'</span>, <span class="string">'Engineer'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</span><br></pre></td></tr></tbody></table></div></figure><p>命名关键字参数可以有缺省值，即默认参数。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命名关键字参数的缺省值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city=<span class="string">'Beijing'</span>, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"><span class="comment">#函数调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br></pre></td></tr></tbody></table></div></figure><h3 id="36-参数组合"><a class="anchorjs-link " href="#36-参数组合" aria-label="Anchor link for: 36 参数组合" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.6 参数组合</h3><p>必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数可以组合使用。但参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数组合的定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a, b, c=<span class="number">0</span>, *, d, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'d ='</span>, d, <span class="string">'kw ='</span>, kw)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#参数组合的调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, x=<span class="number">99</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = {<span class="string">'x'</span>: <span class="number">99</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="keyword">None</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = {<span class="string">'ext'</span>: <span class="keyword">None</span>}</span><br></pre></td></tr></tbody></table></div></figure><p>通过tuple和dict调用参数组合函数：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#f1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = {<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = {<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>}</span><br><span class="line"><span class="comment">#f2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = {<span class="string">'d'</span>: <span class="number">88</span>, <span class="string">'x'</span>: <span class="string">'#'</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = {<span class="string">'x'</span>: <span class="string">'#'</span>}</span><br></pre></td></tr></tbody></table></div></figure><p>对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p><h2 id="4-递归函数"><a class="anchorjs-link " href="#4-递归函数" aria-label="Anchor link for: 4 递归函数" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4. 递归函数</h2><h3 id="41-递归函数的定义"><a class="anchorjs-link " href="#41-递归函数的定义" aria-label="Anchor link for: 41 递归函数的定义" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.1 递归函数的定义</h3><p>递归函数即函数在内部调用函数本身（自己调用自己）。</p><p>递归的关键点：</p><ul><li>递归结束的临界值，通常使用if语句来判断临界值</li><li>递归体的递归逻辑</li></ul><p>例如，以下是fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n 的递归函数。</p><figure class="highlight"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line"><span class="comment">#计算5的阶乘，递归函数调用细节</span></span><br><span class="line">===&gt; fact(5)</span><br><span class="line">===&gt; 5 * fact(4)</span><br><span class="line">===&gt; 5 * (4 * fact(3))</span><br><span class="line">===&gt; 5 * (4 * (3 * fact(2)))</span><br><span class="line">===&gt; 5 * (4 * (3 * (2 * fact(1))))</span><br><span class="line">===&gt; 5 * (4 * (3 * (2 * 1)))</span><br><span class="line">===&gt; 5 * (4 * (3 * 2))</span><br><span class="line">===&gt; 5 * (4 * 6)</span><br><span class="line">===&gt; 5 * 24</span><br><span class="line">===&gt; 120</span><br></pre></td></tr></tbody></table></div></figure><h3 id="42-栈溢出问题"><a class="anchorjs-link " href="#42-栈溢出问题" aria-label="Anchor link for: 42 栈溢出问题" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.2 栈溢出问题</h3><p>&#8203;  在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p><p>例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1000</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact</span><br><span class="line">  ...</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact</span><br><span class="line">RuntimeError: maximum recursion depth exceeded <span class="keyword">in</span> comparison</span><br></pre></td></tr></tbody></table></div></figure><h3 id="43-尾递归"><a class="anchorjs-link " href="#43-尾递归" aria-label="Anchor link for: 43 尾递归" data-anchorjs-icon="ℬ" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.3 尾递归</h3><p>&#8203;  解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化。尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p><p>例如：</p><figure class="highlight"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#尾递归函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#计算5的阶乘，递归函数调用细节</span></span><br><span class="line">===&gt; fact_iter(5, 1)</span><br><span class="line">===&gt; fact_iter(4, 5)</span><br><span class="line">===&gt; fact_iter(3, 20)</span><br><span class="line">===&gt; fact_iter(2, 60)</span><br><span class="line">===&gt; fact_iter(1, 120)</span><br><span class="line">===&gt; 120</span><br></pre></td></tr></tbody></table></div></figure><p>尾递归调用时，如果做了优化，栈不会增长，无论多少次调用也不会导致栈溢出。但实际上大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，因此当没有优化的情况下任何递归函数都存在栈溢出的问题。</p></div>                                                    <div class="aplayer-lrc"></div>                                            </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用pycharm给玛雅写python&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://myblong.zkb/categories/python/"/>
    
    
      <category term="python" scheme="https://myblong.zkb/tags/python/"/>
    
      <category term="python基础" scheme="https://myblong.zkb/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Maya选择插件_PatternSelection</title>
    <link href="https://myblong.zkb/2019/06/13/share/Maya%E9%80%89%E6%8B%A9%E6%8F%92%E4%BB%B6_PatternSelection/"/>
    <id>https://myblong.zkb/2019/06/13/share/Maya选择插件_PatternSelection/</id>
    <published>2019-06-13T14:18:26.790Z</published>
    <updated>2019-06-13T14:19:55.480Z</updated>
    
    <content type="html"><![CDATA[<p>Maya选择插件_PatternSelection<br><a id="more"></a><br><article class="article-content"><p><img src="http://wx2.sinaimg.cn/large/0062H1pggy1fqmy36im8zg30jg0jgqv5.gif" alt="Maya选择插件 PatternSelection" title="Maya选择插件 PatternSelection"></p><p>Pattern Selection是一个maya脚本，它选择当前选中模式中的下一个组件。适用于边缘(循环和环)，顶点和面。最好的解释如上图。</p><p>安装方法：</p><p><span style="color: #99cc00;">第一种（快捷键）</span>：</p><p>将.py文件复制到Documents/maya/版本/scripts 里面</p><p>打开maya，设置快捷键。<img src="http://wx2.sinaimg.cn/large/0062H1pggy1fqmy263vzjj312k0i23zr.jpg" alt="Maya选择插件 PatternSelection" title="Maya选择插件 PatternSelection"></p><p>为下面两段脚本分别设置快捷键：</p><pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">import</span><span class="pln"> patternSelection</span><span class="pun">;</span></li><li class="L1"><span class="pln">patternSelection</span><span class="pun">.</span><span class="pln">patternSelection</span><span class="pun">()</span></li></ol></pre><pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">import</span><span class="pln"> patternSelection</span><span class="pun">;</span></li><li class="L1"><span class="pln">patternSelection</span><span class="pun">.</span><span class="pln">patternSelectionRepeat</span><span class="pun">()</span></li></ol></pre><p>然后保存，重开maya。</p><p><span style="color: #99cc00;">第二种（按钮）</span>：讲上面两段脚本分别拖到工具架。</p><p>&nbsp;</p><table width="397"><colgroup><col width="76"><col width="107"><col width="107"><col width="107"></colgroup><tbody><tr><td width="76">文件名称</td><td colspan="3" width="107">&nbsp;patternSelection</td></tr><tr><td width="76">文件大小</td><td colspan="3" width="107">&nbsp;.py</td></tr><tr><td width="76">文件格式</td><td colspan="3" width="107">&nbsp;10kb</td></tr><tr><td width="76">支持版本</td><td colspan="3" width="107">&nbsp;理论上支持2012+，只测试了2016.5和2017</td></tr><tr><td width="76">备注</td><td colspan="3" width="107"></td></tr><tr><td width="76">下载链接</td><td colspan="3" width="107">https://pan.baidu.com/s/1d1muN0D3Q2oLGY88pS5Sww</td></tr><tr><td width="76">解压密码</td><td colspan="3" width="107">&nbsp;6666</td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p></article></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maya选择插件_PatternSelection&lt;br&gt;
    
    </summary>
    
      <category term="maya插件" scheme="https://myblong.zkb/categories/maya%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="maya插件" scheme="https://myblong.zkb/tags/maya%E6%8F%92%E4%BB%B6/"/>
    
      <category term="分享" scheme="https://myblong.zkb/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>python基础知识学习总结（一）</title>
    <link href="https://myblong.zkb/2019/06/12/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://myblong.zkb/2019/06/12/python基础知识学习总结（一）/</id>
    <published>2019-06-12T14:56:17.651Z</published>
    <updated>2019-06-12T14:56:49.583Z</updated>
    
    <content type="html"><![CDATA[<p>##python基础知识学习总结（一）<br><a id="more"></a><br><article> <aside id="sidebar">        <div id="toc" class="toc-article toc-fixed">        <strong class="toc-title">Contents</strong>                  <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-数据类型和变量"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1. 数据类型和变量</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#11-整数"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1.1 整数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12-浮点数"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">1.2 浮点数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#13-字符串"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">1.3 字符串</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#14-布尔值"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">1.4 布尔值</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#15-空值"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">1.5 空值</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#16-变量"><span class="toc-nav-number">1.6.</span> <span class="toc-nav-text">1.6 变量</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#17-常量"><span class="toc-nav-number">1.7.</span> <span class="toc-nav-text">1.7 常量</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#18-总结"><span class="toc-nav-number">1.8.</span> <span class="toc-nav-text">1.8 总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-字符串和编码"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2. 字符串和编码</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#21-字符编码"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">2.1 字符编码</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#22-字符编码使用场景"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">2.2 字符编码使用场景</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#23-python的字符串"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">2.3 Python的字符串</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#24-字符串编码转换"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">2.4 字符串(编码)转换</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#241-encodestrbytes"><span class="toc-nav-number">2.4.1.</span> <span class="toc-nav-text">2.4.1 encode()[str→bytes]</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#242-decodebytesstr"><span class="toc-nav-number">2.4.2.</span> <span class="toc-nav-text">2.4.2 decode()[bytes→str]</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#243-len"><span class="toc-nav-number">2.4.3.</span> <span class="toc-nav-text">2.4.3 len()</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#25-格式化"><span class="toc-nav-number">2.5.</span> <span class="toc-nav-text">2.5 格式化</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#251-的方式"><span class="toc-nav-number">2.5.1.</span> <span class="toc-nav-text">2.5.1 %的方式</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#252-format"><span class="toc-nav-number">2.5.2.</span> <span class="toc-nav-text">2.5.2 format()</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-list和tuple类型"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3. list和tuple类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#31-list"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">3.1 list</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#311-list的定义"><span class="toc-nav-number">3.1.1.</span> <span class="toc-nav-text">3.1.1 list的定义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#312-len"><span class="toc-nav-number">3.1.2.</span> <span class="toc-nav-text">3.1.2 len()</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#313-list的索引"><span class="toc-nav-number">3.1.3.</span> <span class="toc-nav-text">3.1.3 list的索引</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#314-list元素增删"><span class="toc-nav-number">3.1.4.</span> <span class="toc-nav-text">3.1.4 list元素增删</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3141-追加末尾元素"><span class="toc-nav-number">3.1.4.1.</span> <span class="toc-nav-text">3.1.4.1 追加末尾元素</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3142-指定位置插入元素"><span class="toc-nav-number">3.1.4.2.</span> <span class="toc-nav-text">3.1.4.2 指定位置插入元素</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3143-删除末尾元素"><span class="toc-nav-number">3.1.4.3.</span> <span class="toc-nav-text">3.1.4.3 删除末尾元素</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3144-删除指定位置元素"><span class="toc-nav-number">3.1.4.4.</span> <span class="toc-nav-text">3.1.4.4 删除指定位置元素</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#3145-替换元素"><span class="toc-nav-number">3.1.4.5.</span> <span class="toc-nav-text">3.1.4.5 替换元素</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#315多维list"><span class="toc-nav-number">3.1.5.</span> <span class="toc-nav-text">3.1.5多维list</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#316-空list"><span class="toc-nav-number">3.1.6.</span> <span class="toc-nav-text">3.1.6 空list</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#32-tuple"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">3.2 tuple</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#321-tuple的定义"><span class="toc-nav-number">3.2.1.</span> <span class="toc-nav-text">3.2.1 tuple的定义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#322-特别说明"><span class="toc-nav-number">3.2.2.</span> <span class="toc-nav-text">3.2.2 特别说明</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-dict和set类型"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4. dict和set类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#41-dict"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">4.1 dict</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#411-dict的定义"><span class="toc-nav-number">4.1.1.</span> <span class="toc-nav-text">4.1.1 dict的定义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#412-dict的查找"><span class="toc-nav-number">4.1.2.</span> <span class="toc-nav-text">4.1.2 dict的查找</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#413-dict的删除"><span class="toc-nav-number">4.1.3.</span> <span class="toc-nav-text">4.1.3 dict的删除</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#414-特别说明"><span class="toc-nav-number">4.1.4.</span> <span class="toc-nav-text">4.1.4 特别说明</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#42-set"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">4.2 set</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#421-set的定义"><span class="toc-nav-number">4.2.1.</span> <span class="toc-nav-text">4.2.1 set的定义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#422-set的添加和删除"><span class="toc-nav-number">4.2.2.</span> <span class="toc-nav-text">4.2.2 set的添加和删除</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#423-set的交集和并集"><span class="toc-nav-number">4.2.3.</span> <span class="toc-nav-text">4.2.3 set的交集和并集</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#43-不可变对象"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">4.3 不可变对象</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-条件语句"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5. 条件语句</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#51-if格式"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">5.1 if格式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#52-条件简写"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">5.2 条件简写</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#53-input使用"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">5.3 input()使用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-循环语句"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">6. 循环语句</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#61-for循环"><span class="toc-nav-number">6.1.</span> <span class="toc-nav-text">6.1 for循环</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#62-while循环"><span class="toc-nav-number">6.2.</span> <span class="toc-nav-text">6.2 while循环</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#63-break"><span class="toc-nav-number">6.3.</span> <span class="toc-nav-text">6.3 break</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#64-continue"><span class="toc-nav-number">6.4.</span> <span class="toc-nav-text">6.4 continue</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"></li></ol>                </div>      </aside>        <div class="container">        <div class="row">            <!-- Post Container -->            <div class="                col-lg-8 col-lg-offset-2                col-md-10 col-md-offset-1                post-container">                <h2 id="1-数据类型和变量"><a class="anchorjs-link " href="#1-数据类型和变量" aria-label="Anchor link for: 1 数据类型和变量" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1. 数据类型和变量</h2><p>&#8203;  Python使用缩进来组织代码块，一般使用4个空格的缩进。使用<code>#</code>来注释一行，其他每一行都是一个语句，当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块。Python对大小写敏感。</p><h3 id="11-整数"><a class="anchorjs-link " href="#11-整数" aria-label="Anchor link for: 11 整数" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1.1 整数</h3><p>&#8203;  Python可以处理任意大小的整数，包括负整数，写法与数学上写法一致，例如：-100。如果用十六进制表示，则用前缀为<code>0x</code>和<code>0-9</code>，<code>a-f</code>表示，例如：0xff00。</p><h3 id="12-浮点数"><a class="anchorjs-link " href="#12-浮点数" aria-label="Anchor link for: 12 浮点数" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1.2 浮点数</h3><p>&#8203;  浮点数的表示方法：3.14，-9.01。若是科学技术法表示，则10用e代替，例如：1.23$\times10^9$表示为1.23e9。</p><p>&#8203;  整数和浮点数在计算机内存储的方式不同，整数运算永远是精确的（包括除法运算），浮点数运算可能会存在四舍五入的误差。</p><h3 id="13-字符串"><a class="anchorjs-link " href="#13-字符串" aria-label="Anchor link for: 13 字符串" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1.3 字符串</h3><p>&#8203;  字符串是<strong>单引号</strong>或<strong>双引号</strong>括起来的文本。</p><ul><li><p>如果字符串中包含单引号，则用双引号括起来；</p></li><li><p>如果包含双引号，则用单引号括起来；</p></li><li><p>如果既包含单引号又包含双引号，则使用转义字符<code>\</code>来标识，例如：<code>'I\'m \"OK\"!'</code>表示的是<code>I'm "OK"!</code>。</p></li><li><p>python中用<code>r''</code>表示<code>''</code>内部的字符串默认不转义，例如<code>print(r'\\\t\\')</code>即打印<code>\\\t\\</code>。</p></li><li><p>python中用<code>'''...'''</code>三引号来输入多行内容，其中<code>...</code>是提示符，表示接着上一行输入，例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'''line1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line2</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line3'''</span>)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></tbody></table></div></figure></li></ul><h3 id="14-布尔值"><a class="anchorjs-link " href="#14-布尔值" aria-label="Anchor link for: 14 布尔值" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1.4 布尔值</h3><p>&#8203;  布尔值只有<code>True</code>和<code>Flase</code>两种（注意大小写，Python对大小写敏感），常用于if的条件判断。</p><p>&#8203;  布尔值运算规则如下：</p><ul><li><code>and</code>运算是与运算，只有所有都为<code>True</code>，<code>and</code>运算结果才是<code>True</code>。</li><li><code>or</code>运算是或运算，只要其中有一个为<code>True</code>，<code>or</code>运算结果就是<code>True</code>。</li><li><code>not</code>运算是非运算，它是一个单目运算符，把<code>True</code>变成<code>False</code>，<code>False</code>变成<code>True</code>。</li></ul><h3 id="15-空值"><a class="anchorjs-link " href="#15-空值" aria-label="Anchor link for: 15 空值" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1.5 空值</h3><p>&#8203;  空值是Python里一个特殊的值，用<code>None</code>表示。</p><h3 id="16-变量"><a class="anchorjs-link " href="#16-变量" aria-label="Anchor link for: 16 变量" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1.6 变量</h3><p>&#8203;  Python中变量类型不固定，即动态语言，不需要提前声明。使用<code>=</code>直接赋值，同一个变量可以反复赋值，且可以是不同类型的变量。例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span>    <span class="comment">#a是整数，即a指向整数123</span></span><br><span class="line">a = <span class="string">"ABC"</span>  <span class="comment">#将a赋值成字符串，即a指向字符串"ABC"</span></span><br><span class="line">b = a      <span class="comment">#将b指向a所指向的数据("ABC")</span></span><br><span class="line">a = <span class="string">"XYZ"</span>  <span class="comment">#将a指向字符串"XYZ"</span></span><br><span class="line">print(b)   <span class="comment">#打印b将打印"ABC"而不是"XYZ"</span></span><br></pre></td></tr></tbody></table></div></figure><p>&#8203;  变量<code>a="ABC"</code>赋值中，Python解释器处理了以下事项：</p><ol><li>在内存中创建一个<code>"ABC"</code>的字符串；</li><li>在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>"ABC"</code>。</li><li>把a赋值给b，实际上是将b指向<code>a所指向的数据</code>。</li></ol><h3 id="17-常量"><a class="anchorjs-link " href="#17-常量" aria-label="Anchor link for: 17 常量" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1.7 常量</h3><p>&#8203;  常量一般用全部大写的变量名表示，例如：<code>PI=3.14</code>。实际上，Python没有机制保证PI的值不会被改变，所以本质仍然是个变量。</p><p>&#8203;  Python的除法：</p><ul><li><code>/</code>的除法计算结果是浮点数，即使是两个整数相除也是浮点数，例如<code>9 / 3</code>结果为<code>3.0</code>。</li><li><code>//</code>除法只取结果的整数部分，例如<code>10 // 3</code>结果是整数部分3。</li><li><code>%</code>表示取余数，例如：<code>10 % 3</code>结果是余数1。</li></ul><h3 id="18-总结"><a class="anchorjs-link " href="#18-总结" aria-label="Anchor link for: 18 总结" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>1.8 总结</h3><p>&#8203;  Python支持多种数据类型，在计算机内部可以把任何数据看成一个”对象”，而变量赋值就是将变量和数据对象关联起来，即变量指向该数据对象。例如<code>x=y</code>，表示把变量x指向y所指向的数据对象，随后对y的赋值并不影响x的指向。</p><p>&#8203;  Python的整数和浮点数没有大小的限制。若超出一定范围就用<code>inf</code>（无限大）表示。</p><h2 id="2-字符串和编码"><a class="anchorjs-link " href="#2-字符串和编码" aria-label="Anchor link for: 2 字符串和编码" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2. 字符串和编码</h2><h3 id="21-字符编码"><a class="anchorjs-link " href="#21-字符编码" aria-label="Anchor link for: 21 字符编码" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.1 字符编码</h3><ul><li><code>ASCII</code>编码，早期的编码包含大小写英文字母、数字和一些符号，用一个字节（8位）表示。因编码量少可能会出现乱码问题。</li><li><code>Unicode</code>编码，统一各国语言编码，用两个字节（16位）表示。如果文本全是英文，则会比ASCII编码需要多一倍的存储空间，在存储和传输上不划算。</li><li><code>UTF-8</code>编码，即可变长的Unicode编码，UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码能节省空间。</li></ul><h3 id="22-字符编码使用场景"><a class="anchorjs-link " href="#22-字符编码使用场景" aria-label="Anchor link for: 22 字符编码使用场景" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.2 字符编码使用场景</h3><ul><li><p>在计算机内存中，统一使用Unicode编码。</p></li><li><p>当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p>例如：</p><p>&#8203;  用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p><img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1512810598/article/python/basics/UnicodeToUTF-8.png" width="40%"><p>&#8203;  浏览网页的时候，服务器会把动态的生成的Unicode内容转换为UTF-8再传输到浏览器，所以很多网页的源码上会有类似<code>&lt;meta charset="UTF-8" /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</p><img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1512810599/article/python/basics/website-UTF-8.png" width="40%"></li></ul><h3 id="23-python的字符串"><a class="anchorjs-link " href="#23-python的字符串" aria-label="Anchor link for: 23 python的字符串" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.3 Python的字符串</h3><p>&#8203;  Python3的版本中，字符串是Unicode编码，即支持多语言。</p><p>&#8203;  对于单个字符的编码，Python提供<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符。例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">66</span>)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>)</span><br><span class="line"><span class="string">'文'</span></span><br></pre></td></tr></tbody></table></div></figure><p>如果知道字符的整数编码，可以用十六进制写<code>str</code>：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d\u6587'</span></span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></tbody></table></div></figure><h3 id="24-字符串编码转换"><a class="anchorjs-link " href="#24-字符串编码转换" aria-label="Anchor link for: 24 字符串编码转换" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.4 字符串(编码)转换</h3><p>&#8203;  Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>(UTF-8/ASCII编码)。</p><p>&#8203;  Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">b'ABC'</span></span><br></pre></td></tr></tbody></table></div></figure><h4 id="241-encodestrbytes"><a class="anchorjs-link " href="#241-encodestrbytes" aria-label="Anchor link for: 241 encodestrbytes" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.4.1 encode()[str→bytes]</h4><p>&#8203;  以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，即Unicode编码转换成UTF-8编码或ASCII编码，例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="comment">#错误例子</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'ascii'</span>)  </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode characters in position 0-1: ordinal not in range(128)</span></span><br></pre></td></tr></tbody></table></div></figure><h4 id="242-decodebytesstr"><a class="anchorjs-link " href="#242-decodebytesstr" aria-label="Anchor link for: 242 decodebytesstr" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.4.2 decode()[bytes→str]</h4><p>&#8203;  要把UTF-8编码或ASCII编码转换成Unicode编码，即bytes类型转换为str类型，可用decode()转换。例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'中文'</span></span><br><span class="line"><span class="comment">#错误例子</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xff'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">UnicodeDecodeError: <span class="string">'utf-8'</span> codec can<span class="string">'t decode byte 0xff in position 3: invalid start byte</span></span><br></pre></td></tr></tbody></table></div></figure><p>&#8203;  如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors='ignore'</code>忽略错误的字节：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xff'</span>.decode(<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line"><span class="string">'中'</span></span><br></pre></td></tr></tbody></table></div></figure><h4 id="243-len"><a class="anchorjs-link " href="#243-len" aria-label="Anchor link for: 243 len" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.4.3 len()</h4><p>&#8203;  对于<code>str</code>类型len()计算的是字符数，对于<code>bytes</code>类型len()计算的是字节数。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对于str类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment">#对于bytes类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></tbody></table></div></figure><p>&#8203;  1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p><p>&#8203;  为了避免中文乱码，一般使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换，即Unicode→UTF-8。所以一般在Python源文件开头写以下信息：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></tbody></table></div></figure><p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><h3 id="25-格式化"><a class="anchorjs-link " href="#25-格式化" aria-label="Anchor link for: 25 格式化" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.5 格式化</h3><h4 id="251-的方式"><a class="anchorjs-link " href="#251-的方式" aria-label="Anchor link for: 251 的方式" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.5.1 %的方式</h4><p>&#8203;  使用<code>%</code>来格式化字符串，其中<code>%s</code>永远起作用，可以把任何数据类型转换成字符串，如果字符串中包含<code>%</code>，则使用<code>%%</code>转义表示字符串中的<code>%</code>。常用占位符如下：</p><div class="table-responsive"><table class="table"><thead><tr><th>占位符</th><th>替换内容</th></tr></thead><tbody><tr><td>%s</td><td>字符串</td></tr><tr><td>%d</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table></div><p>例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, %s'</span> % <span class="string">'world'</span></span><br><span class="line"><span class="string">'Hello, world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="string">'Hi, Michael, you have $1000000.'</span></span><br><span class="line"><span class="comment">#整数和浮点数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%2d-%02d'</span> % (<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%.2f'</span> % <span class="number">3.1415926</span>)</span><br><span class="line"><span class="comment"># %s的通用性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Age: %s. Gender: %s'</span> % (<span class="number">25</span>, <span class="keyword">True</span>)</span><br><span class="line"><span class="string">'Age: 25. Gender: True'</span></span><br><span class="line"><span class="comment">#转义字符串中的%</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'growth rate: %d %%'</span> % <span class="number">7</span></span><br><span class="line"><span class="string">'growth rate: 7 %'</span></span><br></pre></td></tr></tbody></table></div></figure><h4 id="252-format"><a class="anchorjs-link " href="#252-format" aria-label="Anchor link for: 252 format" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>2.5.2 format()</h4><p>&#8203;  可以使用字符串的<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>{0}</code>、<code>{1}</code>……。但建议直接使用<code>%</code>的方式。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, {0}, 成绩提升了 {1:.1f}%'</span>.format(<span class="string">'小明'</span>, <span class="number">17.125</span>)</span><br><span class="line"><span class="string">'Hello, 小明, 成绩提升了 17.1%'</span></span><br></pre></td></tr></tbody></table></div></figure><h2 id="3-list和tuple类型"><a class="anchorjs-link " href="#3-list和tuple类型" aria-label="Anchor link for: 3 list和tuple类型" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3. list和tuple类型</h2><h3 id="31-list"><a class="anchorjs-link " href="#31-list" aria-label="Anchor link for: 31 list" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1 list</h3><p>list表示列表，是<strong>可变</strong>的<strong>有序</strong>列表，即有序的集合，可以随时添加和删除元素。</p><h4 id="311-list的定义"><a class="anchorjs-link " href="#311-list的定义" aria-label="Anchor link for: 311 list的定义" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.1 list的定义</h4><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></tbody></table></div></figure><h4 id="312-len"><a class="anchorjs-link " href="#312-len" aria-label="Anchor link for: 312 len" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.2 len()</h4><p>用<code>len()</code>函数可以获得list元素的个数</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(classmates)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></div></figure><h4 id="313-list的索引"><a class="anchorjs-link " href="#313-list的索引" aria-label="Anchor link for: 313 list的索引" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.3 list的索引</h4><ul><li>list元素索引从0开始</li><li>索引可以引用负数表示倒数序号，例如classmates[-1]表示倒数最后一个元素，索引<code>-1</code>等价于<code>len(classmates) - 1</code></li><li>索引越界会报<code>IndexError</code>错误，倒序索引也会越界</li></ul><h4 id="314-list元素增删"><a class="anchorjs-link " href="#314-list元素增删" aria-label="Anchor link for: 314 list元素增删" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.4 list元素增删</h4><h5 id="3141-追加末尾元素"><a class="anchorjs-link " href="#3141-追加末尾元素" aria-label="Anchor link for: 3141 追加末尾元素" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.4.1 追加末尾元素</h5><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></tbody></table></div></figure><h5 id="3142-指定位置插入元素"><a class="anchorjs-link " href="#3142-指定位置插入元素" aria-label="Anchor link for: 3142 指定位置插入元素" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.4.2 指定位置插入元素</h5><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</span><br></pre></td></tr></tbody></table></div></figure><h5 id="3143-删除末尾元素"><a class="anchorjs-link " href="#3143-删除末尾元素" aria-label="Anchor link for: 3143 删除末尾元素" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.4.3 删除末尾元素</h5><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</span><br><span class="line"><span class="string">'Adam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></tbody></table></div></figure><h5 id="3144-删除指定位置元素"><a class="anchorjs-link " href="#3144-删除指定位置元素" aria-label="Anchor link for: 3144 删除指定位置元素" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.4.4 删除指定位置元素</h5><p>用pop(i)的方法，i为索引值</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="string">'Jack'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></tbody></table></div></figure><h5 id="3145-替换元素"><a class="anchorjs-link " href="#3145-替换元素" aria-label="Anchor link for: 3145 替换元素" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.4.5 替换元素</h5><p>即直接给对应索引的元素重新赋值。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">'Sarah'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></tbody></table></div></figure><h4 id="315多维list"><a class="anchorjs-link " href="#315多维list" aria-label="Anchor link for: 315多维list" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.5多维list</h4><p>&#8203;  list中元素的数据类型可以不同，如果要实现二维list，即将一维list中的元素定义为list即可，同理可以实现多维list。例如访问二维list可用<code>s[2][1]</code>的方式，表示一维list中的第三个元素list中的第二个元素。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>, [<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></div></figure><h4 id="316-空list"><a class="anchorjs-link " href="#316-空list" aria-label="Anchor link for: 316 空list" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.1.6 空list</h4><p>&#8203;  空list即一个元素也没有，长度为0。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(L)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></tbody></table></div></figure><h3 id="32-tuple"><a class="anchorjs-link " href="#32-tuple" aria-label="Anchor link for: 32 tuple" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.2 tuple</h3><h4 id="321-tuple的定义"><a class="anchorjs-link " href="#321-tuple的定义" aria-label="Anchor link for: 321 tuple的定义" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.2.1 tuple的定义</h4><p>&#8203;  tuple表示元组，即<strong>不可变</strong>的<strong>有序</strong>元素的集合。即没有修改元素的函数，例如append()，insert()，元素赋值等。</p><p>&#8203;  因为tuple元素不可变，所以代码更安全。当定义tuple时，元素就必须被确定下来。如果tuple中只含一个元素，则在该元素后加逗号。避免与小括号运算产生歧义。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以下是单元素tuple的定义</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>,)</span><br><span class="line"><span class="comment">#以下是小括号运算</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></div></figure><h4 id="322-特别说明"><a class="anchorjs-link " href="#322-特别说明" aria-label="Anchor link for: 322 特别说明" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>3.2.2 特别说明</h4><p>tuple中的元素不可变表示元素的指向不可变，但该元素如果是list，则该list的内容可变。即list表示的是指向，该list的指向不可变，但是list中元素的指向可变，即list中的元素可变。例如：</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'X'</span>, <span class="string">'Y'</span>])</span><br></pre></td></tr></tbody></table></div></figure><p>示意图：</p><p>list元素修改前：<code>t = ('a', 'b', ['A', 'B'])</code></p><img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1512810598/article/python/basics/tuple1.png" width="50%"><p>list元素修改后：<code>t = ('a', 'b', ['X', 'Y'])</code></p><img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1512810598/article/python/basics/tuple2.png" width="50%"><h2 id="4-dict和set类型"><a class="anchorjs-link " href="#4-dict和set类型" aria-label="Anchor link for: 4 dict和set类型" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4. dict和set类型</h2><h3 id="41-dict"><a class="anchorjs-link " href="#41-dict" aria-label="Anchor link for: 41 dict" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.1 dict</h3><h4 id="411-dict的定义"><a class="anchorjs-link " href="#411-dict的定义" aria-label="Anchor link for: 411 dict的定义" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.1.1 dict的定义</h4><p>dict即字典，相当于golang中的<code>map</code>类型，key-value型。具有极快的查找速度。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//dict的赋值</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = {<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</span><br><span class="line"><span class="number">95</span></span><br><span class="line">//dict元素的赋值</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Adam'</span>] = <span class="number">67</span></span><br></pre></td></tr></tbody></table></div></figure><p>由于dict中<strong>key的值是唯一</strong>的，因此如果多次赋值，最终结果为最后一次的赋值。</p><h4 id="412-dict的查找"><a class="anchorjs-link " href="#412-dict的查找" aria-label="Anchor link for: 412 dict的查找" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.1.2 dict的查找</h4><p>如果key不存在会报错，检测key是否存在可以通过<code>in</code>或<code>get()</code>方法。当key不存在时，<code>in</code>的方式返回<code>False</code>，<code>get()</code>方法返回<code>None</code>或指定值。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#key不存在的报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Thomas'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="string">'Thomas'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#in方式检查key是否存在</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Thomas'</span> <span class="keyword">in</span> d</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get()方法检查key是否存在</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">'Thomas'</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></tbody></table></div></figure><h4 id="413-dict的删除"><a class="anchorjs-link " href="#413-dict的删除" aria-label="Anchor link for: 413 dict的删除" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.1.3 dict的删除</h4><p>要删除dict中的元素，可以通过用<code>pop(key)</code>方法，删除该key对应的键值对。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">{<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>}</span><br></pre></td></tr></tbody></table></div></figure><h4 id="414-特别说明"><a class="anchorjs-link " href="#414-特别说明" aria-label="Anchor link for: 414 特别说明" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.1.4 特别说明</h4><p><strong>dict的特点</strong>：</p><ol><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li><li>dict的key必须是<strong>不可变对象</strong>，在Python中，字符串、整数等都是不可变的，而list是可变的，就不能作为key。</li></ol><p><strong>对比list的特点</strong>：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><h3 id="42-set"><a class="anchorjs-link " href="#42-set" aria-label="Anchor link for: 42 set" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.2 set</h3><p>&#8203;  set表示无序和无重复元素的集合，与数学意义上的集合类似，也可以看成是只有key没有value的dict。</p><h4 id="421-set的定义"><a class="anchorjs-link " href="#421-set的定义" aria-label="Anchor link for: 421 set的定义" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.2.1 set的定义</h4><p>要创建一个set，需要提供一个list作为输入集合，如果list中有重复元素则自动过滤掉。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line"><span class="comment">#如果有重复元素会自动过滤掉</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br></pre></td></tr></tbody></table></div></figure><h4 id="422-set的添加和删除"><a class="anchorjs-link " href="#422-set的添加和删除" aria-label="Anchor link for: 422 set的添加和删除" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.2.2 set的添加和删除</h4><p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但无效。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>}</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>}</span><br></pre></td></tr></tbody></table></div></figure><p>通过<code>remove(key)</code>方法可以删除元素。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}</span><br></pre></td></tr></tbody></table></div></figure><h4 id="423-set的交集和并集"><a class="anchorjs-link " href="#423-set的交集和并集" aria-label="Anchor link for: 423 set的交集和并集" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.2.3 set的交集和并集</h4><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment">#交集</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">{<span class="number">2</span>, <span class="number">3</span>}</span><br><span class="line"><span class="comment">#并集</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>}</span><br></pre></td></tr></tbody></table></div></figure><h3 id="43-不可变对象"><a class="anchorjs-link " href="#43-不可变对象" aria-label="Anchor link for: 43 不可变对象" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>4.3 不可变对象</h3><p>&#8203;  变量表示一个指向，而变量指向的内容表示一个对象。例如<code>a="abc"</code>中<code>a</code>是变量即指向，而<code>abc</code>是字符串对象。</p><p>&#8203;  Python中整数和字符串是不可变对象，而list是可变对象。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.replace(<span class="string">'a'</span>, <span class="string">'A'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">'Abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'abc'</span></span><br></pre></td></tr></tbody></table></div></figure><p>&#8203;  例如上例中，<code>a</code>是变量，<code>abc</code>是字符串对象，当调用a的<code>replace</code>的方法时，实际上是基于原字符串对象重新创建了一个新的字符串对象<code>Abc</code>，而没有改变原字符串对象的内容。</p><p>&#8203;  对于不变对象来说，调用对象自身的任意方法，不会改变该对象自身的内容。而会创建新的对象并返回。</p><h2 id="5-条件语句"><a class="anchorjs-link " href="#5-条件语句" aria-label="Anchor link for: 5 条件语句" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>5. 条件语句</h2><h3 id="51-if格式"><a class="anchorjs-link " href="#51-if格式" aria-label="Anchor link for: 51 if格式" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>5.1 if格式</h3><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件判断<span class="number">1</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">2</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">3</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;执行<span class="number">4</span>&gt;</span><br></pre></td></tr></tbody></table></div></figure><p>&#8203;  以上是if语句的完整格式，注意事项：</p><ul><li>Python使用缩进规则，如果if判断条件为true，则执行缩进部分的内容。</li><li>if的执行逻辑是从上往下判断，如果某个判断为true，则会忽略剩下的<code>elif</code>和<code>else</code>。</li></ul><p>例如：以下例子打印的结果是teenager，即满足第一个if条件则后续判断不再执行。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'kid'</span>)</span><br></pre></td></tr></tbody></table></div></figure><h3 id="52-条件简写"><a class="anchorjs-link " href="#52-条件简写" aria-label="Anchor link for: 52 条件简写" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>5.2 条件简写</h3><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    print(<span class="string">'True'</span>)</span><br></pre></td></tr></tbody></table></div></figure><p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p><h3 id="53-input使用"><a class="anchorjs-link " href="#53-input使用" aria-label="Anchor link for: 53 input使用" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>5.3 input()使用</h3><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = input(<span class="string">'birth: '</span>)</span><br><span class="line">birth = int(s)</span><br><span class="line"><span class="keyword">if</span> birth &lt; <span class="number">2000</span>:</span><br><span class="line">    print(<span class="string">'00前'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'00后'</span>)</span><br></pre></td></tr></tbody></table></div></figure><p><code>input()</code>返回的数据类型是<code>str</code>，<code>str</code>不能直接和整数比较，必须先把<code>str</code>转换成整数。Python提供了<code>int()</code>函数来转换成整数。</p><h2 id="6-循环语句"><a class="anchorjs-link " href="#6-循环语句" aria-label="Anchor link for: 6 循环语句" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>6. 循环语句</h2><h3 id="61-for循环"><a class="anchorjs-link " href="#61-for循环" aria-label="Anchor link for: 61 for循环" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>6.1 for循环</h3><p>for…in循环，即把list或tuple中的每个元素迭代出来，执行后续操作。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></tbody></table></div></figure><p>Python提供一个<code>range(x)</code>函数，生成<code>0-(x-1)</code>的整数序列。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">//求和运算</span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></tbody></table></div></figure><h3 id="62-while循环"><a class="anchorjs-link " href="#62-while循环" aria-label="Anchor link for: 62 while循环" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>6.2 while循环</h3><p>while循环，只要条件满足，就不断循环，条件不满足时退出循环。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></tbody></table></div></figure><h3 id="63-break"><a class="anchorjs-link " href="#63-break" aria-label="Anchor link for: 63 break" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>6.3 break</h3><p>在循环中，<code>break</code>语句可以提前退出循环。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">10</span>: <span class="comment"># 当n = 11时，条件满足，执行break语句</span></span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># break语句会结束当前循环</span></span><br><span class="line">    print(n)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></tbody></table></div></figure><h3 id="64-continue"><a class="anchorjs-link " href="#64-continue" aria-label="Anchor link for: 64 continue" data-anchorjs-icon="?" style="position: absolute; margin-left: -1em; padding-right: 0.5em;"></a>6.4 continue</h3><p>在循环过程中，可以通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环。</p><figure class="highlight python"><div class="table-responsive"><table class="table"><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 如果n是偶数，执行continue语句</span></span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span></span><br><span class="line">    print(n)</span><br></pre></td></tr></tbody></table></div></figure><p><code>break</code>和<code>continue</code>通常都必须配合<code>if</code>语句使用。</p>                                <hr></div></div>      <style>      span.toc-nav-number{        display: none      }    </style>                                      <section>                                     </section></div>            </article></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##python基础知识学习总结（一）&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://myblong.zkb/categories/python/"/>
    
    
      <category term="python" scheme="https://myblong.zkb/tags/python/"/>
    
      <category term="python基础" scheme="https://myblong.zkb/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python开发工具</title>
    <link href="https://myblong.zkb/2019/06/12/python%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <id>https://myblong.zkb/2019/06/12/python开发工具/</id>
    <published>2019-06-12T14:19:16.040Z</published>
    <updated>2019-06-12T14:21:50.584Z</updated>
    
    <content type="html"><![CDATA[<p>##PyCharm是一种Python IDE<br><a id="more"></a><br><article class="article-content">            <p><img src="http://www.jetbrains.com/pycharm/img/screenshots/simpleLook@2x.jpg" alt="Python高效开发工具 JetBrains PyCharm Professional 2018.3.1" title="Python高效开发工具 JetBrains PyCharm Professional 2018.3.1"></p><p style="text-align: center;">官网&nbsp;<a href="http://www.jetbrains.com/pycharm/" rel="external" data-original-title="" title="" target="_blank">http://www.jetbrains.com/pycharm/</a></p><p>PyCharm是一种Python IDE，带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发。</p><div class="para-title level-2"><h2 class="title-text">主要功能</h2><p><a class="edit-icon j-edit-link" data-edit-dl="3" data-original-title="" title="">编辑</a></p></div><div class="para"><b>编码协助</b></div><div class="para"><p>其提供了一个带编码补全，代码片段，支持代码折叠和分割窗口的智能、可配置的编辑器，可帮助用户更快更轻松的完成编码工作。</p><div class="lemma-picture text-pic layout-right"><a class="image-link" title="" href="https://baike.baidu.com/pic/PyCharm/8143824/0/35a85edf8db1cb139d0ec2bddd54564e92584b3d?fr=lemma&amp;ct=single" target="_blank" rel="noopener" data-original-title=""><img class="" src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D250/sign=796e921cb2b7d0a27fc90398fbee760d/35a85edf8db1cb139d0ec2bddd54564e92584b3d.jpg" title="Python高效开发工具 JetBrains PyCharm Professional 2018.3.1" alt="Python高效开发工具 JetBrains PyCharm Professional 2018.3.1"></a></div></div><div class="para"><b>项目代码导航</b></div><div class="para">该IDE可帮助用户即时从一个文件导航至另一个，从一个方法至其申明或者用法甚至可以穿过类的层次。若用户学会使用其提供的快捷键的话甚至能更快。</div><div class="para"><b>代码分析</b></div><div class="para">用户可使用其编码语法，错误高亮，智能检测以及一键式代码快速补全建议，使得编码更优化。</div><div class="para"><b>Python重构</b></div><div class="para">有了该功能，用户便能在项目范围内轻松进行重命名，提取方法/超类，导入域/变量/常量，移动和前推/后退重构。</div><div class="para"><b>支持Django</b></div><div class="para"><p>有了它自带的HTML，CSS和 JavaScript编辑器 ，用户可以更快速的通过Djang框架进行Web开发。此外，其还能支持CoffeeScript， Mako 和 Jinja2。</p><div class="lemma-picture text-pic layout-right"><a class="image-link" title="" href="https://baike.baidu.com/pic/PyCharm/8143824/0/5243fbf2b21193132a15011e65380cd790238dce?fr=lemma&amp;ct=single" target="_blank" rel="noopener" data-original-title=""><img class="" src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=c385f6f355fbb2fb302b5f107f4b2043/5243fbf2b21193132a15011e65380cd790238dce.jpg" title="Python高效开发工具 JetBrains PyCharm Professional 2018.3.1" alt="Python高效开发工具 JetBrains PyCharm Professional 2018.3.1"></a></div></div><div class="para"><b>支持Google App引擎</b></div><div class="para">用户可选择使用Python 2.5或者2.7运行环境，为Google App引擎进行应用程序的开发，并执行例行程序部署工作。</div><div class="para"><b>集成版本控制</b></div><div class="para">登入，录出，视图拆分与合并–所有这些功能都能在其统一的VCS用户界面（可用于Mercurial， Subversion， Git， Perforce 和其他的 SCM）中得到。</div><div class="para"><b>图形页面调试器</b></div><div class="para">用户可以用其自带的功能全面的调试器对Python或者Django应用程序以及测试单元进行调整，该调试器带断点，步进，多画面视图，窗口以及评估表达式。</div><div class="para"><b>集成的单元测试</b></div><div class="para"><p>用户可以在一个文件夹运行一个测试文件，单个测试类，一个方法或者所有测试项目。</p><div class="lemma-picture text-pic layout-right"><a class="image-link" title="" href="https://baike.baidu.com/pic/PyCharm/8143824/0/4a36acaf2edda3ccd185468e01e93901213f923f?fr=lemma&amp;ct=single" target="_blank" rel="noopener" data-original-title=""><img class="" src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D250/sign=c63f3dba6b600c33f479d9cd2a4d5134/4a36acaf2edda3ccd185468e01e93901213f923f.jpg" title="Python高效开发工具 JetBrains PyCharm Professional 2018.3.1" alt="Python高效开发工具 JetBrains PyCharm Professional 2018.3.1"></a></div></div><div class="para"><b>可自定义&amp;可扩展</b></div><div class="para">可绑定了&nbsp;<a href="https://baike.baidu.com/item/Textmate" target="_blank" rel="noopener" data-original-title="" title="">Textmate</a>，&nbsp;<a href="https://baike.baidu.com/item/NetBeans" target="_blank" rel="noopener" data-original-title="" title="">NetBeans</a>， Eclipse &amp; Emacs 键盘主盘，以及 Vi/Vim仿真插件。</div><div></div><div><table><tbody><tr><td width="76">文件名称</td><td colspan="3" rowspan="1" width="107">JetBrains PyCharm Professional 2018.3.1 Windows</td></tr><tr><td width="76">文件大小</td><td colspan="3" rowspan="1" width="107">267MB</td></tr><tr><td width="76">文件格式</td><td colspan="3" rowspan="1" width="107">.zip</td></tr><tr><td width="76">备注</td><td colspan="3" rowspan="1" width="107">内附安装说明</td></tr><tr><td width="76">下载链接</td><td colspan="3" rowspan="1" width="107">链接: <a href="https://pan.baidu.com/s/1euMMbLTOD3W5igX5Haw6OA" rel="external" data-original-title="" title="" target="_blank">https://pan.baidu.com/s/1euMMbLTOD3W5igX5Haw6OA</a> 提取码: qprv </td></tr></tbody></table></div>    </article></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##PyCharm是一种Python IDE&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://myblong.zkb/categories/python/"/>
    
    
      <category term="python" scheme="https://myblong.zkb/tags/python/"/>
    
      <category term="python基础" scheme="https://myblong.zkb/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>python学习_1</title>
    <link href="https://myblong.zkb/2019/06/12/python%E5%AD%A6%E4%B9%A0_1/"/>
    <id>https://myblong.zkb/2019/06/12/python学习_1/</id>
    <published>2019-06-11T16:01:44.201Z</published>
    <updated>2019-06-11T16:04:11.271Z</updated>
    
    <content type="html"><![CDATA[<p>使用pycharm给玛雅写python<br><a id="more"></a><br><div class="blog-content-box">  <div class="article-header-box">    <div class="article-header">      <div class="article-title-box">      </div>      <div class="article-info-box">        <div class="operating">                  </div>      </div>    </div>  </div>  <article class="baidu_pl">    <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f57960eb32.css">                              <div id="content_views" class="markdown_views prism-atom-one-dark">            <!-- flowchart 箭头图标 勿删 -->            <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">              <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"/>            </svg>            <h1><a name="t0"></a><a id="maya_python__0" target="_blank"></a>maya python 的简单使用</h1><h3><a name="t1"></a><a id="pycharmpython_2" target="_blank"></a>使用pycharm给玛雅写python</h3><blockquote><p>里边含有玛雅命令自动提示的配置<br><code>https://download.csdn.net/download/bigtail_cat/10543887</code> 文件下载网址</p></blockquote><h5><a id="_6" target="_blank"></a>基本图形的创建</h5><pre class="prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)"><span class="token comment"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> maya<span class="token punctuation">.</span>cmds <span class="token keyword">as</span> cmds<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    cmds<span class="token punctuation">.</span>polySphere<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment"># 创建默认的小球</span>    cmds<span class="token punctuation">.</span>polySphere<span class="token punctuation">(</span>r<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>   <span class="token comment"># 创建半径为5的小球</span>    cmds<span class="token punctuation">.</span>polyColorPerVertex<span class="token punctuation">(</span>colorRGB<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> colorDisplayOption<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">#设置小球的颜色</span>    cmds<span class="token punctuation">.</span>polyCube<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'myCube'</span><span class="token punctuation">,</span> depth<span class="token operator">=</span><span class="token number">12.5</span><span class="token punctuation">,</span> height<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">#创建立方体</span>    <span class="token keyword">print</span> <span class="token punctuation">(</span>cmds<span class="token punctuation">.</span><span class="token builtin">help</span><span class="token punctuation">(</span><span class="token string">'polyCube'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                      <span class="token comment"># 查看polyCube函数的参数列表</span>    <span class="token comment">#下面两种创建立方体方式等同</span>    cmds<span class="token punctuation">.</span>polyCube<span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> h<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> d<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> sx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> sy<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> sz<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> ax<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cuv<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> ch<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span>polyCube<span class="token punctuation">(</span>width<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>                  height<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>                  depth<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>                  subdivisionsX<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>                  subdivisionsY<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>                  subdivisionsZ<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>                  axis<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                  createUVs<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>                  constructionHistory<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li></ul></pre><h5><a id="_32" target="_blank"></a>根据创建的小球获得信息并改变小球的大小</h5><pre class="prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)"><span class="token comment"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> maya<span class="token punctuation">.</span>cmds <span class="token keyword">as</span> cmds<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    sphere <span class="token operator">=</span> cmds<span class="token punctuation">.</span>polySphere<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment"># 创建默认的小球</span>    cmds<span class="token punctuation">.</span>polySphere<span class="token punctuation">(</span>r<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>            <span class="token comment"># 创建半径为5的小球</span>    cmds<span class="token punctuation">.</span>polyColorPerVertex<span class="token punctuation">(</span>colorRGB<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> colorDisplayOption<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment">#设置小球的颜色</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sphere<span class="token punctuation">)</span>    rad <span class="token operator">=</span> cmds<span class="token punctuation">.</span>polySphere<span class="token punctuation">(</span>sphere<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> radius<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment"># 获取小球的半径</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'the sphere radius is %d'</span> <span class="token operator">%</span>rad<span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span>polySphere<span class="token punctuation">(</span>sphere<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> radius<span class="token operator">=</span>rad <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment"># 将小球的半径扩大二倍</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li></ul></pre><h5><a id="getAttr__setAttr__49" target="_blank"></a>getAttr 和 setAttr 获得和设置属性</h5><pre class="prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)"><span class="token keyword">import</span> maya<span class="token punctuation">.</span>cmds <span class="token keyword">as</span> cmds<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    loc <span class="token operator">=</span> cmds<span class="token punctuation">.</span>spaceLocator<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment"># 创建打印定位器</span>    <span class="token keyword">print</span> loc    sx <span class="token operator">=</span> cmds<span class="token punctuation">.</span>getAttr<span class="token punctuation">(</span>loc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'.scaleX'</span><span class="token punctuation">)</span>    <span class="token comment"># 获得locator的scaleX</span>    cmds<span class="token punctuation">.</span>setAttr<span class="token punctuation">(</span>loc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'.scaleX'</span><span class="token punctuation">,</span> sx <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># 修改locator的scaleX</span>    <span class="token comment"># 同下效果</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>cmds<span class="token punctuation">.</span>xform<span class="token punctuation">(</span>loc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> q<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> translation<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 获得打印定位器的位置</span>    cmds<span class="token punctuation">.</span>xform<span class="token punctuation">(</span>loc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> translation<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token comment"># 移动打印定位器的位置</span>    <span class="token comment">#同上效果</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>cmds<span class="token punctuation">.</span>getAttr<span class="token punctuation">(</span>loc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'.translate'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token comment"># 获得打印定位器的位置</span>    cmds<span class="token punctuation">.</span>setAttr<span class="token punctuation">(</span>loc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'.translate'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>         <span class="token comment"># 移动打印定位器的位置</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li></ul></pre><h5><a id="connectAttr__disconnectAttr__68" target="_blank"></a>connectAttr 和 disconnectAttr 连接与断开属性连接</h5><pre class="prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)"><span class="token comment"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> maya<span class="token punctuation">.</span>cmds <span class="token keyword">as</span> cmds<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    sphere <span class="token operator">=</span> cmds<span class="token punctuation">.</span>polySphere<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">#创建小球</span>    cube   <span class="token operator">=</span> cmds<span class="token punctuation">.</span>polyCube<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment"># 创建立方体</span>    cmds<span class="token punctuation">.</span>connectAttr<span class="token punctuation">(</span>cube <span class="token operator">+</span> <span class="token string">'.ry'</span><span class="token punctuation">,</span> sphere <span class="token operator">+</span> <span class="token string">'.ty'</span><span class="token punctuation">)</span> <span class="token comment">#将立方体的y-rotation连接到球体的y-translation</span>    cmds<span class="token punctuation">.</span>disconnectAttr<span class="token punctuation">(</span>cube <span class="token operator">+</span> <span class="token string">'.ry'</span><span class="token punctuation">,</span> sphere <span class="token operator">+</span> <span class="token string">'.ty'</span><span class="token punctuation">)</span>  <span class="token comment"># 断开连接</span>    <span class="token comment">#立方体每旋转九十度 小球旋转一个单位</span>    mult <span class="token operator">=</span> cmds<span class="token punctuation">.</span>createNode<span class="token punctuation">(</span><span class="token string">'multiplyDivide'</span><span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span>connectAttr<span class="token punctuation">(</span>cube <span class="token operator">+</span> <span class="token string">'.ry'</span><span class="token punctuation">,</span> mult <span class="token operator">+</span> <span class="token string">'.input1X'</span><span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span>setAttr<span class="token punctuation">(</span>mult <span class="token operator">+</span> <span class="token string">'.input2X'</span><span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">90.0</span><span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span>connectAttr<span class="token punctuation">(</span>mult <span class="token operator">+</span> <span class="token string">'.outputX'</span><span class="token punctuation">,</span> sphere <span class="token operator">+</span> <span class="token string">'.ty'</span><span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span>select<span class="token punctuation">(</span>cube<span class="token punctuation">)</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li></ul></pre><h5><a id="addAttr__88" target="_blank"></a>addAttr 增加属性</h5><pre class="prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)"><span class="token comment"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> maya<span class="token punctuation">.</span>cmds <span class="token keyword">as</span> cmds<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    cmds<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">(</span>new<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> f<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    sphere_xform<span class="token punctuation">,</span> sphere_shape <span class="token operator">=</span> cmds<span class="token punctuation">.</span>polySphere<span class="token punctuation">(</span>n<span class="token operator">=</span><span class="token string">'Earth'</span><span class="token punctuation">)</span>    <span class="token comment"># 添加属性</span>    cmds<span class="token punctuation">.</span>addAttr<span class="token punctuation">(</span>sphere_xform<span class="token punctuation">,</span> attributeType<span class="token operator">=</span><span class="token string">'float'</span><span class="token punctuation">,</span> shortName<span class="token operator">=</span><span class="token string">'mass'</span><span class="token punctuation">,</span> longName<span class="token operator">=</span><span class="token string">'mass'</span><span class="token punctuation">,</span> defaultValue<span class="token operator">=</span><span class="token number">5.9742e24</span><span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span>addAttr<span class="token punctuation">(</span>sphere_xform<span class="token punctuation">,</span> dataType<span class="token operator">=</span><span class="token string">'string'</span><span class="token punctuation">,</span> shortName<span class="token operator">=</span><span class="token string">'alt'</span><span class="token punctuation">,</span> longName<span class="token operator">=</span><span class="token string">'alternateName'</span><span class="token punctuation">)</span>    <span class="token comment"># 向属性中添加值 设置属性</span>    cmds<span class="token punctuation">.</span>setAttr<span class="token punctuation">(</span>sphere_xform <span class="token operator">+</span> <span class="token string">'.alternateName'</span><span class="token punctuation">,</span> <span class="token string">'Terra'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token string">'string'</span><span class="token punctuation">)</span>    <span class="token comment"># 获得属性值</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>cmds<span class="token punctuation">.</span>getAttr<span class="token punctuation">(</span>sphere_xform <span class="token operator">+</span> <span class="token string">'.mass'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>cmds<span class="token punctuation">.</span>getAttr<span class="token punctuation">(</span>sphere_xform <span class="token operator">+</span> <span class="token string">'.alt'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li></ul></pre><h5><a id="_110" target="_blank"></a>创建窗口</h5><pre class="prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)"><span class="token comment"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> maya<span class="token punctuation">.</span>cmds <span class="token keyword">as</span> cmds<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment"># 创建一个窗口</span>    win <span class="token operator">=</span> cmds<span class="token punctuation">.</span>window<span class="token punctuation">(</span><span class="token string">'ar_optionsWindow'</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">'first window'</span><span class="token punctuation">,</span> widthHeight<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">546</span><span class="token punctuation">,</span> <span class="token number">350</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span>showWindow<span class="token punctuation">(</span>win<span class="token punctuation">)</span>    <span class="token comment"># 修改项目标题</span>    cmds<span class="token punctuation">.</span>deleteUI<span class="token punctuation">(</span>win<span class="token punctuation">,</span> window<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    win <span class="token operator">=</span> cmds<span class="token punctuation">.</span>window<span class="token punctuation">(</span><span class="token string">'ar_optionsWindow'</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">'second window'</span><span class="token punctuation">,</span> widthHeight<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">546</span><span class="token punctuation">,</span> <span class="token number">350</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span>showWindow<span class="token punctuation">(</span>win<span class="token punctuation">)</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li></ul></pre><h5><a id="ls__select__128" target="_blank"></a>ls 与 select 列出与选择节点</h5><pre class="prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)"><span class="token comment"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> maya<span class="token punctuation">.</span>cmds <span class="token keyword">as</span> cmds<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment"># 打印场景里边的所有节点</span>    nodes <span class="token operator">=</span> cmds<span class="token punctuation">.</span>ls<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    <span class="token comment"># 打印场景中所有transform类型的节点</span>    nodes <span class="token operator">=</span> cmds<span class="token punctuation">.</span>ls<span class="token punctuation">(</span><span class="token builtin">type</span><span class="token operator">=</span><span class="token string">'transform'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    <span class="token comment"># 打印场景中所有以persp开头名字的节点</span>    nodes <span class="token operator">=</span> cmds<span class="token punctuation">.</span>ls<span class="token punctuation">(</span><span class="token string">'persp*'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span>    <span class="token comment">#打印当前场景中选中的节点</span>    cmds<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token string">'side*'</span><span class="token punctuation">,</span> <span class="token string">'top*'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>cmds<span class="token punctuation">.</span>ls<span class="token punctuation">(</span>selection<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span>select<span class="token punctuation">(</span>cmds<span class="token punctuation">.</span>ls<span class="token punctuation">(</span><span class="token builtin">type</span><span class="token operator">=</span><span class="token string">'shape'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>cmds<span class="token punctuation">.</span>ls<span class="token punctuation">(</span>sl<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li></ul></pre><h5><a id="file__154" target="_blank"></a>file 场景中文件的创建与打开</h5><pre class="prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.copyCode(event)"><span class="token comment"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> os<span class="token keyword">import</span> maya<span class="token punctuation">.</span>cmds <span class="token keyword">as</span> cmds<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    cmds<span class="token punctuation">.</span>polyCube<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 保存场景中的所有文件</span>    path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getenv<span class="token punctuation">(</span><span class="token string">'HOME'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'cuba.ma'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span> path    cmds<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">(</span>rename<span class="token operator">=</span>path<span class="token punctuation">)</span>    cmds<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">(</span>save<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment">#新建场景并打开文件</span>    cmds<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">(</span>new<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> force<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getenv<span class="token punctuation">(</span><span class="token string">'HOME'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'cuba.ma'</span><span class="token punctuation">)</span>  <span class="token comment"># 打开文件</span>    <span class="token keyword">print</span> path    cmds<span class="token punctuation">.</span><span class="token builtin">file</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token builtin">open</span><span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> force<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li></ul></pre>          </div>          <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-258a4616f7.css" rel="stylesheet">                  </div>  </article></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用pycharm给玛雅写python&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://myblong.zkb/categories/python/"/>
    
    
      <category term="python" scheme="https://myblong.zkb/tags/python/"/>
    
      <category term="python基础" scheme="https://myblong.zkb/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>mari4.5新特性</title>
    <link href="https://myblong.zkb/2019/06/11/share/mari4.5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://myblong.zkb/2019/06/11/share/mari4.5新特性/</id>
    <published>2019-06-10T16:34:01.764Z</published>
    <updated>2019-06-10T16:35:25.990Z</updated>
    
    <content type="html"><![CDATA[<p>FOUNDRY（F）：你是怎么第一次来使用Mari的？<br>GaëlKerchenbaum（GK）：我在2013年至2014年期间在ArtFx的最后一年学习中开始使用Mari。</p><p>那时，如果你想在VFX行业找到一份工作，这是你需要知道的工具之一。今天，情况仍然如此。<br><a id="more"></a><br><div class="post-wrap ">            <p><a href="https://www.linkedin.com/in/gaelkerchenbaum/" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ga?lKerchenbaum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一位自由角色生物艺术家和导师。</font><font style="vertical-align: inherit;">他曾在包括培根图片，Noemotion，</font></font><a href="http://capsule.studio/" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">胶囊工作室</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="http://www.axisanimation.com/" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轴心动画</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://www.moving-picture.com/" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在内的工作室工作</font><font style="vertical-align: inherit;">，在那里他生下了Jungle Book动物的团队。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ga?l是The Rookies的杰出评委之一，是第一批获得</font></font><a href="https://www.foundry.com/products/mari/non-commercial" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">期待已久的材料系统的人之一，该系统最近作为Mari 4.5版本的一部分提供。</font></font></p><p><font style="vertical-align: inherit;"></font><a href="https://www.foundry.com/" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foundry</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">团队向</font><font style="vertical-align: inherit;">他介绍了他使用新材料系统创建本文附带的惊人资产的经验。</font></font></p><h3 id="foundry-f-how-did-you-first-come-to-use-mari"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FOUNDRY（F）：你是怎么第一次来使用Mari的？</font></font></h3><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ga?lKerchenbaum（GK）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font><font style="vertical-align: inherit;">在2013年至2014年期间</font><font style="vertical-align: inherit;">在</font><a href="https://artfx.school/en/" target="_blank" rel="external"><font style="vertical-align: inherit;">ArtFx的</font></a><font style="vertical-align: inherit;">最后一年学习中</font><font style="vertical-align: inherit;">开始使用</font></font><a href="https://www.foundry.com/products/mari/non-commercial" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><a href="https://artfx.school/en/" target="_blank" rel="external"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那时，如果你想在VFX行业找到一份工作，这是你需要知道的工具之一。</font><font style="vertical-align: inherit;">今天，情况仍然如此。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我独自</font><font style="vertical-align: inherit;">学习了</font></font><a href="https://www.foundry.com/products/mari/non-commercial" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并爱上了它。</font><font style="vertical-align: inherit;">我一直都在进行建模，而</font></font><a href="https://www.foundry.com/products/mari/non-commercial" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一直是我从建模到浮出水面的天然桥梁。</font><font style="vertical-align: inherit;">多亏了这个工具，我学会了大大提高我的生物质量，并将它们推向我追求的现实主义水平。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我从来没有找到任何其他纹理工具让我感觉完全控制我的表面处理工作流程。</font><font style="vertical-align: inherit;">能够实时纹理位移，显示我当前地图的平面显示，以及预览我在视口中的渲染是我一直需要的东西。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这只是Mari可以做的一瞥。</font></font></p><h3 id="f-you-re-one-of-the-first-people-to-get-their-hands-on-the-new-mari-materials-system-take-us-through-how-you-used-it-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F：你是第一批掌握新Mari材料系统的人之一。</font><font style="vertical-align: inherit;">带我们了解您如何使用它。</font></font></h3><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（GK）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为一名自由生物艺术家，找到快速有效的方法为我的客户制作工作对我来说非常重要。</font><font style="vertical-align: inherit;">同样重要的是，我可以为我将添加到我的投资组合中的下一个生物感到自豪。</font><font style="vertical-align: inherit;">当Foundry让我试一下Mari的新版本时，我想把我的一个旧雕塑从一个简单的3D模型推到一个漂亮的渲染。</font><font style="vertical-align: inherit;">我喜欢在3D中创建看起来像收藏品或实际雕像的模型。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们的想法是在具有不同材料和水泥污垢和侵蚀的有机模型上创建硬表面纹理。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说实话，在</font></font><a href="https://www.foundry.com/products/mari/non-commercial" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari 4.5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之前</font><font style="vertical-align: inherit;">，我会在软件中以同样的方式完成它; </font><font style="vertical-align: inherit;">nodegraph已经为此惊人了。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然而，现在的不同之处在于我可以制作自己的大理石，青铜，金和铜绿材料。</font><font style="vertical-align: inherit;">我花了几个小时才习惯它，但经过一些调查，我设法构建完全程序化的着色器，我可以随时定制。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几个小时创建我自己的材料，这将在几分钟内轻松应用于我的下一个项目......这正是我正在寻找的那种工具！</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里的另一个不同之处在于，根据我的感受，如果我对纹理的某个方面不满意，我可以回到我的材料的节点图中并将其更改为我喜欢的任何内容。</font></font></p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://www.foundry.com/sites/default/files/inline-images/01_Arnold_Surface_Shader.jpg" class="kg-image lightense-target" alt="Arnold Surface Shader"></figure><!--kg-card-end: image--><h3 id="-f-how-did-it-feel-to-have-a-procedural-material-workflow-inside-of-mari"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（F）：在Mari内部有一个程序材料工作流程感觉如何？</font></font></h3><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（GK）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我从不喜欢做纹理投影。</font><font style="vertical-align: inherit;">我在</font></font><a href="https://www.foundry.com/products/mari/non-commercial" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投影的唯一纹理是</font><font style="vertical-align: inherit;">来自</font></font><a href="https://texturing.xyz/" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TexturingXYZ的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">置换贴图</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我总是试图找到一种方法来创建完全程序的反照率，镜面反射和粗糙度图。</font><font style="vertical-align: inherit;">我相信这是创建纹理绑定到表面信息的唯一方法。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我对纹理投影的另一个问题，特别是反照率（漫反射）地图，是你可以花费多年时间试图杀死扫描中的镜面反射或阴影。</font><font style="vertical-align: inherit;">即使他们被清理干净，细节也会丢失，缺少对比。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出于这个原因，我总是接受程序工作流程。</font><font style="vertical-align: inherit;">我以前用基于图层的方法做到了，并且我已经在几周内爱上了nodegraph。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过在我的材料属性中公开节点的设置，材料工作流程帮助我进一步提高效率。</font></font></p><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（F）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您能否快速浏览一下您将资产放在一起的过程？</font></font></p><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（GK）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">老实说，我对能够通过大量UDIM应用完全程序性材料而不影响视口中的性能有点怀疑。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但我决定尝试一下，无论如何要将我的模型展开到很多UDIM中。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成后，我将UV导入</font></font><a href="2019/academic-and-educational-license/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZBrush</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后返回到中/高多级子分区。</font><font style="vertical-align: inherit;">我摧毁了所有的子工具并保留了紫外线。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在马里工作时，对我来说很重要的是要了解细节，接近阿诺德的流离失所。</font><font style="vertical-align: inherit;">所有的子工具都在我导入Mari的一个OBJ中。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我花了一点时间找到在Mari的nodegraph中构建材料的最佳方法。</font><font style="vertical-align: inherit;">一开始，我试图立刻建立每个频道。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不要这样做。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">构建着色器的最佳方法是从一个地图开始。</font><font style="vertical-align: inherit;">根据您所使用的材料类型，电介质或电子材料，您必须为最具代表性的通道构建树。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[电子材料主要是金属，表面颜色会影响镜面反射。</font><font style="vertical-align: inherit;">电介质最常见的是非金属表面，其表面颜色不会影响镜面反射]</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，您将能够将其分解为其他地图。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先确定是否要构建反照率，镜面反射或凹凸。</font><font style="vertical-align: inherit;">使用与默认着色器输入值对应的颜色节点填充所有其他输入。</font><font style="vertical-align: inherit;">如果您决定从反照率开始，首先使用颜色节点构建原色。</font><font style="vertical-align: inherit;">合并它们并使用程序环境遮挡节点作为掩码。</font><font style="vertical-align: inherit;">使用亮度查找对这些蒙版进行评级（例如）。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成初选后，使用HSV或HSL节点处理辅助节点。</font><font style="vertical-align: inherit;">将它们合并在一起时，请使用不同的程序云作为蒙版。</font><font style="vertical-align: inherit;">然后添加三级颜色以在环境遮挡中添加更多细节和污垢。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成反照率后，您可以创建凹凸和高光贴图。</font><font style="vertical-align: inherit;">使用不同的云，将使用坡度或亮度查找调整进行评级，以便为凹凸提供音量。</font><font style="vertical-align: inherit;">然后将它们合并在一起</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只需将它们插入物料输入即可查看视口中的影响。</font><font style="vertical-align: inherit;">如果你有这两个地图的基础，使用你的反照率地图中的程序云，并插入它们要求你的凹凸，镜面和粗糙度。</font><font style="vertical-align: inherit;">这将为您提供漫反射和标量贴图之间的完美对应。</font></font><br></p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://www.foundry.com/sites/default/files/inline-images/02_Material_Masks.jpg" class="kg-image lightense-target" alt="材料面具"></figure><!--kg-card-end: image--><h3 id="-f-moving-forward-do-you-see-the-materials-system-allowing-you-to-tackle-a-wider-range-of-look-development-with-mari"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（F）：继续前进，您是否看到材料系统允许您使用Mari进行更广泛的外观开发？</font></font></h3><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（GK）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绝对！</font><font style="vertical-align: inherit;">在看到纹理的影响之前，我不想花太多时间等待渲染。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari视口一直是我继续推动我的外观开发技巧的一种方式。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在作为纹理艺术家的生产环境中工作时，您需要了解地图中的原始值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能够在视口中使用平面显示清楚地查看这些值，然后打开我的着色器预览是必须的。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari现在集成了Arnold表面着色器的最新版本，这一事实将帮助我节省更多时间而无需将内容推送到渲染引擎。 &nbsp;</font></font></p><h3 id="-f-as-an-artist-what-do-you-see-as-the-core-benefits-of-being-able-to-create-both-really-detailed-assets-and-higher-volume-but-less-detailed-assets-in-a-single-package"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（F）：作为一名艺术家，您认为能够在一个包中创建真正详细的资产和更高容量（但不那么详细）的资产的核心好处是什么？</font></font></h3><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（GK）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这显然是一种生产效率。</font><font style="vertical-align: inherit;">能够在模型上进入真正高度的细节似乎总是很复杂。</font><font style="vertical-align: inherit;">然而，现在感谢Mari几年了，现在只需几个小时。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能够尽可能详细地了解您的生产时间表。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在有了新的材料系统，您将能够几乎自动地纹理大量资产，并确信它们看起来很逼真，同时花费更多时间专注于您的英雄资产。</font><font style="vertical-align: inherit;">这绝对是一个巨大的节省时间。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对我而言，最重要的是 - 我决定使用我的工具集的方法之一 - 就是专注于艺术性。</font><font style="vertical-align: inherit;">当我向客户展示模型时，能够出售这件作品很重要。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然而，作为一名自由职业者，了解生产所需的时间也是关键。</font><font style="vertical-align: inherit;">拥有我们自己的工作流程提前开发的材料，以便我可以快速自定义它们并轻松地将它们应用到我的资产中，这将节省大量时间。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这也将让我花更多的时间在重要的微调上，比如让我的雕塑更加准确和细致，同时确保纹理准备就绪，这样生产就可以继续前进。</font></font></p><h3 id="-f-do-you-have-any-tips-or-tricks-you-could-share-that-make-using-the-materials-system-easier"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（F）：您是否有任何可以分享的提示或技巧，使材料系统更容易？</font></font></h3><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（GK）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">材料的危险在于新艺术家可能会尝试同时处理其纹理的各个方面。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在教授外观开发时，我总是警告学生不要这样做。</font><font style="vertical-align: inherit;">能够单独阅读每个频道是非常重要的 - 并且只需查看平面地图就可以清楚地了解结果。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示渲染引擎实时预览的视口应该是一个额外的工具，用于确认地图的值是否有意义。</font><font style="vertical-align: inherit;">因此，您需要逐个处理材料的每个通道。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在开发大理石材料时发现的另一个捷径是在其他一切之前创建程序性ISO（隔离）掩模。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里的想法是为每个图案构建一个黑白掩模。</font><font style="vertical-align: inherit;">然后你将这个面具插入你的反照率，以控制特定颜色的重新分区。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将其插入凹凸通道以添加一些高程，或插入镜面和粗糙度以控制着色器的外观。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的最后一个提示，我要感谢Mari团队的Charli，就是将每个材料树分成每个通道组。</font><font style="vertical-align: inherit;">材质是一个英雄组，可以包含一个子组。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您希望子组与通道对应。</font><font style="vertical-align: inherit;">然后展开你想要保持对每个子组的控制的旋钮，而不必深入挖掘。用一个清晰&#8203;&#8203;简单的名称重命名每个暴露的旋钮。</font><font style="vertical-align: inherit;">这将确保您的材料属性在暴露时可以理解。</font></font></p><!--kg-card-begin: image--><figure class="kg-card kg-image-card"><img src="https://www.foundry.com/sites/default/files/inline-images/03_Exposing_Group_Knobs.jpg" class="kg-image lightense-target" alt="组旋钮"></figure><!--kg-card-end: image--><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（F）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般来说，Mari允许你做什么在其他工具中要么不可能要么要困难得多？</font></font></p><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（GK）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UDIM和我在工作的所有方面之间的完整对应。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不仅是一名建模师，也是一名纹理和外观开发艺术家。</font><font style="vertical-align: inherit;">我几乎完全依赖于生物。</font><font style="vertical-align: inherit;">他们需要让我的客户看起来真实，他们希望能够使用它们近距离拍摄。</font></font></p><p><a href="https:/" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是唯一能够通过非破坏性和生产效率工作流程达到这种真实水平的工具。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保持一切程序化非常重要。</font><font style="vertical-align: inherit;">有时，我会被要求在纹理化完成后修改我的模型。</font></font></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因为我使用从几何体生成的蒙版来控制我的所有曲面，所以我只需要重新计算我的ISO并在Mari中更新它们以自动重新生成所有的频道。</font></font></p><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（F）：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感谢您的时间Ga?l - 以及您制作的绝佳资产！</font></font></p><!--kg-card-begin: html--><p><a href="https://www.foundry.com/insights/film-tv/material-system-mari?wvideo=cqhq6sy7sv" class="link-image" target="_blank" rel="external"><img src="https://embedwistia-a.akamaihd.net/deliveries/dfabb65f70927ffdf6c96d990f76bb9b.jpg?image_play_button_size=2x&amp;image_crop_resized=960x540&amp;image_play_button=1&amp;image_play_button_color=d6931ee0" width="400" height="225" style="width: 800px; height: 450px;" class="no-lightense"></a></p><p><a href="https://www.foundry.com/insights/film-tv/material-system-mari?wvideo=cqhq6sy7sv" target="_blank" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari 4.5 | </font><font style="vertical-align: inherit;">狮子</font></font></a></p><!--kg-card-end: html-->        </div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FOUNDRY（F）：你是怎么第一次来使用Mari的？&lt;br&gt;GaëlKerchenbaum（GK）：我在2013年至2014年期间在ArtFx的最后一年学习中开始使用Mari。&lt;/p&gt;
&lt;p&gt;那时，如果你想在VFX行业找到一份工作，这是你需要知道的工具之一。今天，情况仍然如此。&lt;br&gt;
    
    </summary>
    
      <category term="mari" scheme="https://myblong.zkb/categories/mari/"/>
    
    
      <category term="分享" scheme="https://myblong.zkb/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="mari4.5新特性" scheme="https://myblong.zkb/tags/mari4-5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>性能比较Innobright+Altus</title>
    <link href="https://myblong.zkb/2019/06/10/share/%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83Innobright+Altus/"/>
    <id>https://myblong.zkb/2019/06/10/share/性能比较Innobright+Altus/</id>
    <published>2019-06-10T15:17:47.614Z</published>
    <updated>2019-06-10T15:19:52.797Z</updated>
    
    <content type="html"><![CDATA[<p>Innobright 的 Altus 是世界上第一个多平台，蒙特卡罗渲染系统。我们让您生成快速、噪点的渲染，每个像素的较小采样(SPP)，并过滤它们以产生高质量的图像和动画。我们给你你想要的质量，只是时间的一小部分。<br><a id="more"></a><br><article class="article-content">            <h1 style="text-align: center;">Altus 性能比较</h1><p>Innobright 的 Altus 是世界上第一个多平台，蒙特卡罗渲染系统。我们让您生成快速、噪点的渲染，每个像素的较小采样(SPP)，并过滤它们以产生高质量的图像和动画。我们给你你想要的质量，只是时间的一小部分。</p><div class="section" id="features"><h2>功能</h2><div class="wy-table-responsive"><table class="docutils" border="1"><colgroup><col width="19%"><col width="16%"><col width="21%"><col width="22%"><col width="21%"> </colgroup><thead valign="bottom"><tr class="row-odd"><th class="head"><strong>功能</strong></th><th class="head"><span class="gbg">Altus 支持</span></th><th class="head"><strong>V-Ray Denosier 支持</strong></th><th class="head"><strong>Corona Denosier 支持</strong></th><th class="head"><strong>RMan Denosier 支持</strong></th></tr></thead><tbody valign="top"><tr class="row-even"><td>独立</td><td><strong>Yes</strong></td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr class="row-odd"><td>GUI 选项</td><td><strong>Yes</strong></td><td>Yes</td><td>No</td><td>No</td></tr><tr class="row-even"><td>任何 PBR 渲染器</td><td><strong>Yes</strong></td><td>No</td><td>No</td><td>No</td></tr><tr class="row-odd"><td>HW 加速</td><td><strong>Yes</strong></td><td>Yes</td><td>No</td><td>Yes</td></tr><tr class="row-even"><td>GPU 支持</td><td><strong>Yes</strong></td><td>No</td><td>No</td><td>No</td></tr><tr class="row-odd"><td>Animation 支持</td><td><strong>Yes</strong></td><td>No</td><td>No</td><td>Yes</td></tr><tr class="row-even"><td>去除亮斑</td><td><strong>Yes</strong></td><td>No</td><td>Yes</td><td>No</td></tr><tr class="row-odd"><td>过滤 AOVs 以及 RGB</td><td><strong>Yes</strong></td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr class="row-even"><td>快速预览模式</td><td><strong>Yes</strong></td><td>No</td><td>No</td><td>No</td></tr></tbody></table></div></div><div class="section" id="performance"><h2>性能</h2><div class="admonition note"><p class="first admonition-title">日志</p><p>这些数字是在一台有以下规格的电脑上收集的:</p><div class="wy-table-responsive"><table class="last docutils" border="1"><colgroup><col width="10%"><col width="29%"><col width="21%"><col width="21%"><col width="21%"> </colgroup><thead valign="bottom"><tr class="row-odd"><th class="head"><strong>OS</strong></th><th class="head"><strong>CPU</strong></th><th class="head"><strong>RAM Memory</strong></th><th class="head"><strong>GPU</strong></th><th class="head"><strong>VRAM</strong></th></tr></thead><tbody valign="top"><tr class="row-even"><td>Windows</td><td>Intel Core i7-4770 @3.10GHz</td><td>12GB</td><td>NVIDIA GeForce GTX 960</td><td>4GB</td></tr></tbody></table></div></div><div class="wy-table-responsive"><table class="docutils" border="1"><colgroup><col width="8%"><col width="11%"><col width="11%"><col width="14%"><col width="14%"><col width="14%"><col width="14%"><col width="13%"> </colgroup><thead valign="bottom"><tr class="row-odd"><th class="head"></th><th class="head" colspan="7">消耗时间 (mm:ss)</th></tr><tr class="row-even"><th class="head"><strong>图像尺寸</strong></th><th class="head"><span class="gbg">Altus 预览(GPU)</span></th><th class="head"><span class="gbg">Altus 预览(CPU)</span></th><th class="head"><span class="gbg">Altus 产品级(GPU)</span></th><th class="head"><span class="gbg">Altus 产品级(CPU)</span></th><th class="head"><strong>V-Ray Denosier</strong></th><th class="head"><strong>Corona Denosier</strong></th><th class="head"><strong>RMan Denosier</strong></th></tr></thead><tbody valign="top"><tr class="row-odd"><td>3000×3000</td><td>00:53</td><td>01:43</td><td>05:20</td><td>09:36</td><td>3:04</td><td>2:49</td><td>11:52</td></tr><tr class="row-even"><td>1920×1080</td><td>00:11</td><td>00:37</td><td>00:59</td><td>03:40</td><td>0:26</td><td>0:41</td><td>02:36</td></tr><tr class="row-odd"><td>960×540</td><td>00:03</td><td>00:09</td><td>00:15</td><td>00:54</td><td>0:07</td><td>0:16</td><td>00:44</td></tr></tbody></table></div></div><div class="section" id="quality-vs-pbr-denoisers"><h2>Quality vs PBR Denoisers</h2><p>这一节包含与其他表示器的比较。每个场景都在 Renderman, V-Ray, Corona 渲染，然后用它们的整体去噪。然后在渲染之后，所有需要的 AOVs 都被导出并用于与 Altus 去噪的 beauty pass。除非另有说明，所有指示符都使用默认设置。</p><div class="section" id="renderman"><h3>Renderman</h3><div class="figure align-center" id="id1"><p><img width="2000" height="1809" title="Innobright Altus 性能比较" class="alignnone size-full" alt="Innobright Altus 性能比较" src="https://mixcg-1256075144.cos.ap-guangzhou.myqcloud.com/Altus-NeatImage%20(2).jpg"></p><p class="caption"><span class="caption-text">左: Altus Denoiser&nbsp; ，右: Renderman Denoiser</span></p></div><div class="admonition note"><p class="first admonition-title">日志</p><p class="last">质量差异:在光线不足的情况下，Renderman 倾向于留下 blotchy 阴影。如果对暴露进行调整以清楚地看到差异，这就变得很明显了。边缘的阴影，在轮胎下和内部处理都出现了斑点。</p></div></div><div class="section" id="corona"><h3>Corona</h3><div class="figure align-center" id="id2"><p><img width="1913" height="996" title="Innobright Altus 性能比较" class="alignnone size-full" alt="Innobright Altus 性能比较" src="https://mixcg-1256075144.cos.ap-guangzhou.myqcloud.com/Altus-NeatImage%20(3).jpg"></p><p class="caption"><span class="caption-text">左: Altus Denoiser， 右: Corona Denoiser</span></p></div><div class="admonition note"><p class="first admonition-title">日志</p><p class="last">质量差异:Corona 在阴影区域留下残留噪点。</p></div></div><div class="section" id="v-ray"><h3>V-Ray</h3><div class="figure align-center" id="id3"><p><img width="1917" height="838" title="Innobright Altus 性能比较" class="alignnone size-full" alt="Innobright Altus 性能比较" src="https://mixcg-1256075144.cos.ap-guangzhou.myqcloud.com/Altus-NeatImage%20(4).jpg"></p><p class="caption"><span class="caption-text">左: Altus Denoiser， 右: V-Ray Denoiser</span></p></div><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">质量差异:V-Ray 表示在反射中难以保存细节。V-Ray 图像在立方体上有模糊的反射，在球面上有模糊的折射。</p></div></div></div><div class="section" id="quality-vs-generic-film-denoisers"><h2>Quality vs Generic Film Denoisers</h2><div class="admonition warning"><p class="first admonition-title">注意</p><p class="last">下面的结果来自两个通用的图像空间表示，它们只在 RGB 图像上运行，不能包含任何 AOV/特征信息。通常这些表示器是用来清除胶片上的噪点。这意味着这些指示符将会很快，但会产生更糟糕的质量输出。所有这样的比较都是不公平的，但也包括在内。</p></div><div class="section" id="neat-image"><h3>Neat-Image</h3><div class="figure align-center" id="id4"><p><img width="1920" height="1080" title="Innobright Altus 性能比较" class="alignnone size-full" alt="Innobright Altus 性能比较" src="https://mixcg-1256075144.cos.ap-guangzhou.myqcloud.com/Altus-NeatImage%20(1).jpg"></p><p class="caption"><span class="caption-text">使用的 Neat-Image 设置:100%还原，150%噪点水平。</span></p></div><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">质量差异:即使在使用了更极端的过滤器参数之后，NeatImage 表示者也无法去除围绕在天花板上的明亮噪点。</p></div></div><div class="section" id="revision-fx-de-noiser"><h3>Revision FX DE:Noiser</h3><div class="figure align-center" id="id5"><p><img width="1496" height="841" title="Innobright Altus 性能比较" class="alignnone size-full" alt="Innobright Altus 性能比较" src="https://mixcg-1256075144.cos.ap-guangzhou.myqcloud.com/Altus-NeatImage%20(5).jpg"></p><p>DE:Noiser<span class="caption-text">噪点设置: Variational reduction 类型，空间阈值 50%，空间半径 3。</span></p></div><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">质量差异:DE:Noiser 在没有模糊其他图像的情况下，无法消除光的噪点。</p></div></div></div><div class="section" id="download-links"><h2>下载链接</h2><blockquote><div><div class="admonition note"><dl class="last docutils"><dt>上面提到的三个场景:Austin Martin, Cornell Box, Sponza。Altus、V-Ray、Corona 和 Renderman 的每个输出都包括未压缩和 exr 格式。</dt><dd><a title="" class="reference external" href="https://drive.google.com/file/d/0B1qS9hgD_Sn2V0ZHR3V4YmN4MGc/view?usp=sharing" target="_blank" rel="nofollow" data-original-title="">https://drive.google.com/file/d/0B1qS9hgD_Sn2V0ZHR3V4YmN4MGc/view?usp=sharing</a> (392M)</dd></dl></div></div></blockquote></div><div class="section" id="full-performance-table"><h2>完整性能表</h2><p>本节包含在多台计算机上收集的性能/计时信息，这些信息的范围从慢到快。每个场景都在 Renderman, V-Ray, Corona 渲染，然后用它们的整体去噪。然后在渲染之后，所有需要的 AOVs 都被导出，然后用 Altus 的去噪器来去除 beauty pass。</p><div class="section" id="austin-martin-scene"><h3>Austin Martin 场景:</h3><div class="admonition note"><p class="first admonition-title">Note</p><p>这一场景渲染为 3000×3000，然后去噪。这台电脑可以分类为慢。计算机规范:</p><div class="wy-table-responsive"><table class="last docutils" border="1"><colgroup><col width="10%"><col width="29%"><col width="21%"><col width="21%"><col width="21%"> </colgroup><thead valign="bottom"><tr class="row-odd"><th class="head"><strong>OS</strong></th><th class="head"><strong>CPU</strong></th><th class="head"><strong>RAM Memory</strong></th><th class="head"><strong>GPU</strong></th><th class="head"><strong>VRAM</strong></th></tr></thead><tbody valign="top"><tr class="row-even"><td>Windows</td><td>Intel Core i7-4510U @2.0 – 2.6GHz</td><td>8GB</td><td>NVIDIA GeForce GTX 860M</td><td>1GB</td></tr></tbody></table></div></div><div class="wy-table-responsive"><table class="docutils" border="1"><colgroup><col width="9%"><col width="2%"><col width="9%"><col width="12%"><col width="12%"><col width="3%"><col width="8%"><col width="7%"><col width="5%"><col width="11%"><col width="5%"><col width="11%"><col width="5%"> </colgroup><thead valign="bottom"><tr class="row-odd"><th class="head" colspan="3"></th><th class="head" colspan="10">消耗时间 (h:mm:ss)</th></tr><tr class="row-even"><th class="head" colspan="2">渲染器</th><th class="head"><strong>图像尺寸</strong></th><th class="head">渲染时间</th><th class="head">渲染器 Denoise 时间</th><th class="head" colspan="2"><span class="gbg">Altus 预览(GPU)</span></th><th class="head" colspan="2"><span class="gbg">Altus 预览(CPU)</span></th><th class="head" colspan="2"><span class="gbg">Altus 产品级(GPU)</span></th><th class="head" colspan="2"><span class="gbg">Altus 产品级(CPU)</span></th></tr></thead><tbody valign="top"><tr class="row-odd"><td colspan="2">Renderman</td><td>3000×3000</td><td>0:30:51</td><td>0:20:42</td><td colspan="2">01:25</td><td colspan="2">03:20</td><td colspan="2">06:21</td><td colspan="2">15:54</td></tr><tr class="row-even"><td colspan="2">V-Ray</td><td>3000×3000</td><td>0:10:45</td><td>0:21:45</td><td colspan="2">01:15</td><td colspan="2">03:20</td><td colspan="2">06:20</td><td colspan="2">16:02</td></tr><tr class="row-odd"><td colspan="2">Corona</td><td>3000×3000</td><td>8:29:52</td><td>0:13:15</td><td colspan="2">01:17</td><td colspan="2">03:19</td><td colspan="2">06:21</td><td colspan="2">16:01</td></tr></tbody></table></div></div><div class="section" id="cornell-box-scene"><h3>Cornell Box 场景:</h3><div class="admonition note"><p class="first admonition-title">Note</p><p>这个场景在 1920×1080 被渲染，然后去噪。这台电脑可以分类为快。计算机规范:</p><div class="wy-table-responsive"><table class="last docutils" border="1"><colgroup><col width="10%"><col width="29%"><col width="21%"><col width="21%"><col width="21%"> </colgroup><thead valign="bottom"><tr class="row-odd"><th class="head"><strong>OS</strong></th><th class="head"><strong>CPU</strong></th><th class="head"><strong>RAM Memory</strong></th><th class="head"><strong>GPU</strong></th><th class="head"><strong>VRAM</strong></th></tr></thead><tbody valign="top"><tr class="row-even"><td>Windows</td><td>Intel Xeon CPU E5-1650 v3 @ 3.50GHz</td><td>32GB</td><td>NVIDIA GeForce GTX TITAN</td><td>8GB</td></tr></tbody></table></div></div><div class="wy-table-responsive"><table class="docutils" border="1"><colgroup><col width="9%"><col width="2%"><col width="9%"><col width="12%"><col width="12%"><col width="3%"><col width="8%"><col width="7%"><col width="5%"><col width="11%"><col width="5%"><col width="11%"><col width="5%"> </colgroup><thead valign="bottom"><tr class="row-odd"><th class="head" colspan="3"></th><th class="head" colspan="10">Elapsed Time (h:mm:ss)</th></tr><tr class="row-even"><th class="head" colspan="2">渲染器</th><th class="head"><strong>图像尺寸</strong></th><th class="head">渲染时间</th><th class="head">渲染器 Denoise 时间</th><th class="head" colspan="2"><span class="gbg">Altus 预览(GPU)</span></th><th class="head" colspan="2"><span class="gbg">Altus 预览(CPU)</span></th><th class="head" colspan="2"><span class="gbg">Altus 产品级(GPU)</span></th><th class="head" colspan="2"><span class="gbg">Altus 产品级(CPU)</span></th></tr></thead><tbody valign="top"><tr class="row-odd"><td colspan="2">Renderman</td><td>1920×1080</td><td>0:01:21</td><td>0:00:56</td><td colspan="2">00:08</td><td colspan="2">00:22</td><td colspan="2">00:27</td><td colspan="2">01:52</td></tr><tr class="row-even"><td colspan="2">V-Ray</td><td>1920×1080</td><td>0:00:45</td><td>0:00:40</td><td colspan="2">00:08</td><td colspan="2">00:22</td><td colspan="2">00:27</td><td colspan="2">01:56</td></tr><tr class="row-odd"><td colspan="2">Corona</td><td>1920×1080</td><td>0:10:00</td><td>0:00:20</td><td colspan="2">00:08</td><td colspan="2">00:22</td><td colspan="2">00:27</td><td colspan="2">01:56</td></tr></tbody></table></div></div><div class="section" id="sponza-scene"><h3>Sponza 场景:</h3><div class="admonition note"><p class="first admonition-title">Note</p><p>这个场景在 950×540 的时候被渲染，然后去噪。这台电脑可以归类为中档。计算机规范:</p><div class="wy-table-responsive"><table class="last docutils" border="1"><colgroup><col width="10%"><col width="29%"><col width="21%"><col width="21%"><col width="21%"> </colgroup><thead valign="bottom"><tr class="row-odd"><th class="head"><strong>OS</strong></th><th class="head"><strong>CPU</strong></th><th class="head"><strong>RAM Memory</strong></th><th class="head"><strong>GPU</strong></th><th class="head"><strong>VRAM</strong></th></tr></thead><tbody valign="top"><tr class="row-even"><td>Windows</td><td>Intel Core i5-4460 @3.20GHz</td><td>12GB</td><td>NVIDIA GeForce GTX 760</td><td>2GB</td></tr></tbody></table></div></div><div class="wy-table-responsive"><table class="docutils" border="1"><colgroup><col width="9%"><col width="2%"><col width="9%"><col width="12%"><col width="12%"><col width="3%"><col width="8%"><col width="7%"><col width="5%"><col width="11%"><col width="5%"><col width="11%"><col width="5%"> </colgroup><thead valign="bottom"><tr class="row-odd"><th class="head" colspan="3"></th><th class="head" colspan="10">Elapsed Time (h:mm:ss)</th></tr><tr class="row-even"><th class="head" colspan="2">渲染器</th><th class="head"><strong>图像尺寸</strong></th><th class="head">渲染时间</th><th class="head">渲染器 Denoise 时间</th><th class="head" colspan="2"><span class="gbg">Altus 预览(GPU)</span></th><th class="head" colspan="2"><span class="gbg">Altus 预览(CPU)</span></th><th class="head" colspan="2"><span class="gbg">Altus 产品级(GPU)</span></th><th class="head" colspan="2"><span class="gbg">Altus 产品级(CPU)</span></th></tr></thead><tbody valign="top"><tr class="row-odd"><td colspan="2">Renderman</td><td>950×540</td><td>0:11:38</td><td>0:02:16</td><td colspan="2">00:05</td><td colspan="2">00:14</td><td colspan="2">00:18</td><td colspan="2">01:12</td></tr><tr class="row-even"><td colspan="2">V-Ray</td><td>950×540</td><td>0:03:02</td><td>0:00:06</td><td colspan="2">00:05</td><td colspan="2">00:14</td><td colspan="2">00:18</td><td colspan="2">01:12</td></tr><tr class="row-odd"><td colspan="2">Corona</td><td>950×540</td><td>0:01:47</td><td>0:00:16</td><td colspan="2">00:05</td><td colspan="2">00:14</td><td colspan="2">00:18</td><td colspan="2">01:12</td></tr></tbody></table></div></div></div></article></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Innobright 的 Altus 是世界上第一个多平台，蒙特卡罗渲染系统。我们让您生成快速、噪点的渲染，每个像素的较小采样(SPP)，并过滤它们以产生高质量的图像和动画。我们给你你想要的质量，只是时间的一小部分。&lt;br&gt;
    
    </summary>
    
      <category term="Photogrammetry" scheme="https://myblong.zkb/categories/Photogrammetry/"/>
    
    
      <category term="Innobright" scheme="https://myblong.zkb/tags/Innobright/"/>
    
      <category term="Altus" scheme="https://myblong.zkb/tags/Altus/"/>
    
  </entry>
  
  <entry>
    <title>Photogrammetry 完全指南</title>
    <link href="https://myblong.zkb/2019/06/09/share/Photogrammetry%20%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://myblong.zkb/2019/06/09/share/Photogrammetry 完全指南/</id>
    <published>2019-06-09T14:07:52.923Z</published>
    <updated>2019-06-09T14:54:37.864Z</updated>
    
    <content type="html"><![CDATA[<p>Photogrammetry 完全指南<br>Vlad Kuzmin 分享了很多摄影测量的技巧。学习如何扫描真实世界的物体，清理和渲染。.<br><a id="more"></a><br><div><!DOCTYPE html><!-- saved from url=(0034)https://www.iiicg.com/archives/881 --><html xmlns:wb="http://open.weibo.com/wb"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=10,IE=9,IE=8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0"><link href="https://www.iiicg.com/favicon.ico" rel="icon" type="image/x-icon"><meta name="robots" content="index,follow"><meta name="robots" content="noindex,follow"><link rel="stylesheet" id="wp-block-library-css" href="./Photogrammetry 完全指南_files/style.min.css" type="text/css" media="all"><link rel="stylesheet" id="dwqa-style-css" href="./Photogrammetry 完全指南_files/style.css" type="text/css" media="all"><link rel="stylesheet" id="dwqa-rtl-css" href="./Photogrammetry 完全指南_files/rtl.css" type="text/css" media="all"><link rel="stylesheet" id="wp-search-suggest-css" href="./Photogrammetry 完全指南_files/wpss-search-suggest.css" type="text/css" media="all"><link rel="stylesheet" id="style-css" href="./Photogrammetry 完全指南_files/style(1).css" type="text/css" media="all"><script src="./Photogrammetry 完全指南_files/hm.js.下载"></script><script src="./Photogrammetry 完全指南_files/hm.js(1).下载"></script><script type="text/javascript" src="./Photogrammetry 完全指南_files/jquery.min.js.下载"></script><meta name="keywords" content="photogrammetry, 其他软件"><meta name="description" content="原文地址 https://80.lv/articles/full-photogrammetry-guide-for-3d-artists/  本文为有道翻译+人工修改，有些地方可能翻译不准确，请大家反映。   Vlad Kuzmin 分享了很多摄影测量的技巧。学习如何扫描真实世界的物体，清理和渲染。. -  - 指定计划     一个好的摄影测量的成功取决于正确的计划。这意味着不仅仅是充满电的相机电池和相机三脚架。而且不只是"><style type="text/css" id="custom-background-css">body.custom-background { background-color: #3a3a3a; background-image: url("https://www.iiicg.com/wp-content/themes/Git-alpha/assets/img/bg.png"); background-position: left top; background-size: auto; background-repeat: repeat; background-attachment: fixed; }</style><style type="text/css" id="wp-custom-css">body.custom-background {    background: #202020;}.content-wrap {    background:transparent;}/*幻灯片*/.slick {    margin-bottom: 10px;}/*文章列表*/.excerpt {    background-color: #2d2d2d;border: 1px #535353 solid;margin-bottom: 5px;}/*文章文字*/.article-content {font-size: .85rem;letter-spacing: 0em;    line-height: 1.3rem;background-color: transparent; color: #191970;border: 1px #535353 solid;}/*文章2级标题*/.article-content h2 {border-bottom: 0px solid #00a67c;    margin: 0px 0px 0px 0px;background-color: #233c4a;color: #d9e3de;border-left: 0px solid #00a67c;}/*文章3级标题*/.article-content h3 {    margin: 0px 0px 0px 0px;    background-color: #116080;}h1, h2, h3, h4, h5 {    line-height: 1.5rem;}.article-header {  border-bottom: 1px solid #7a7777;    background-color: transparent;}.card-item {    background-color: transparent;}.pagination {    background-color: transparent;}.card-item {    border: 10px solid transparent;        border-bottom-width: 0px;        border-bottom-style: solid;        border-bottom-color: rgb(255, 255, 255);}.speedbar {    background-color: #2d2d2d;}.widget {    background-color: transparent;}.article-title a {    color: #c6c6c6;}.breadcrumbs {    background-color: #3e3e3e;}.article-footer {    background-color: #fff;}.article-nav {    background-color: #272727;}.article-footer {  border-top: 0px solid #f7f7f7;    background-color: #272727;}.widget_calendar table tbody td, .widget_calendar table tfoot td, .widget_calendar table thead th {    border: 1px solid #364850;}.widget_calendar table thead th {    background-color: #15181b;}.social {    background-color: transparent;}#footbar > ul {    left: 65%;}.related_posts {    background-color: transparent;}.relates {    background-color: transparent;}.comt-title {    background-color: #283b39;}body {font-size: .88rem;    color: #a5a5a5;}.archive-header {    background-color: transparent;}.speedbar {    color: #9cce6e;}.widget_links li a {    background-color: #333738;}.navbar .nav > li {    margin-right: 0px;  bottom: 0px;}.nav i {    vertical-align: middle;}.g-mono {    font-size: 0;}.g-bloger {    font-size: 0;}.article-content blockquote {    border: 1px solid #325865;background-color: #3b3b3b;}.slick span {    background-color: rgba(0,0,0,0.5);}.hot-posts h2 {line-height: 5rem;    font-size: 1.2rem;}.title {    border-bottom: 0px solid #90bba8;   display:none}.navbar {    clear: both;opacity: 1;}.container {    max-width: 1400px;}.navbar .nav {    max-width: 1400px;}.slick-slide img, .slick-slider .slick-list, .slick-track {    width: 100%;}.git_postlist li a {    border-bottom: solid 1px #5d5d5d;    font-size: .8rem;}.archive-header h1 {    font-size: 1.0rem;}.pagesidebar {    background-color: transparent;}.pagesider-menu a {    border-bottom: 0px solid }.pagesider-menu li.active a, .pagesider-menu li.current-menu-item a, .pagesider-menu li.current_page_item a {    margin-right: -1px;    background-color: #285457;    color: #fff;}.pagecontent {    border-left: 1px solid #566d6f;}.pageheader h1 a {    display: none;}.pageheader {    border-bottom: 0px solid #eee;}/*问答插件*/.dwqa-alert-info {    color: #9c9983;    background-color: #6a776433;    border-color: transparent;    text-align: center;}.dwqa-search input {    background: url(//www.mixcg.com/wp-content/plugins/dw-question-answer/templates/assets/css/../img/icon-search.png) no-repeat right 10px center transparent !important  ;    padding: 0px 15px; color: white;}label {    display: block;    margin-bottom: 15px;}.submit-dwqa-question .dwqa-search input {    background: none no-repeat right 0px center transparent !important;}.dwqa-content-edit-form input[type="text"], .dwqa-content-edit-form input[type="email"], .dwqa-content-edit-form select {    width: 15%;}.dwqa-comment-form .comment-form textarea {    background: #2d2e32;    color: white;}.dwqa-comments-list {    background: #333;}.dwqa-comment-form {    background: transparent;}.dwqa-answer-form-title {    border-top: 0px solid #ddd;}/*回复列表背景色*/#postcomments {    background-color: transparent;}#respond {    background-color: transparent;}.c-main {    background: #3b4042;}.input-block-level {    background: transparent;}/*回复栏里的文字*/input, select, textarea {    color: #f9f9f9;}/*文章代码*/code {    border: 0px solid #e1e1e8;    background-color: #1e353a;    color: #de9748;    font-size: .75rem;}/*搜索文字*/input, select, textarea {    color: #e7e7e7;}/*搜索栏背景*/.searchform div input.search {    background-color: #2d8475;}.search-expand-inner {    border-bottom: 0px solid #d2d6d5;    border-left: 0px solid #d2d6d5;}/*搜索栏向左移动*/.search-expand {    right: 14px;}/*喇叭*/.speedbar {    background-image: url(https://www.iiicg.com/wp-content/uploads/2018/04/2018041115252569.png);}/*社交图标居中*/.social {    margin-left: 55px;}/*隐藏内容的背景颜色*/.e-secret fieldset {    background: transparent;}.e-secret legend {    background-color: #2b605e;    color: #ddd;}/*文章列表摘要文字颜色*/.excerpt .note {    color: #a5a5a5;}.widget-title {    background: rgba(0, 0, 0, 0.19)!important;}/*下载弹窗页*/#download_button_part {    background: none repeat scroll 0 0 #235580;}.fancybox-skin {    background: #b3b9bc;}#download_button {    width: 300px;}#fancydlbox .dlfooter {    display: none;}/*文章目录缩略图排版*/.card .thumb-img img {width:100%!important;height:auto!important}/*bilibili播放器*/.bilibili-player-video-recommend-container .bilibili-player-video-recommend-panel .title a {    display: none;}.bilibili-player-video-recommend-container .bilibili-player-video-recommend-panel .jump a {    display: none;}.bilibili-player-video-recommend-container .bilibili-player-video-recommend-panel .online i {    display: none;}.bilibili-player-video-recommend-container .bilibili-player-video-recommend-panel .online {    display: none;}/*文章版权声明*/.open-message {    background-color: #2e4440;    color: #d1aa68;   border: #4094efb3 1px solid;}hr {    margin: 100px 0;    border-top: 0px solid #eee;    border-bottom: 0px solid #fff;}#loginbox {    background: #57a294;}/*文章代码正常字体*/.prettyprint .com {    color: #999;    font-style: normal !important;}/*文章绿色提示*/#sc_notice {    overflow: hidden;    margin: 10px 0;    padding: 15px 15px 15px 35px;    border: 1px solid #aac66d;    background: #3d451f url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAMAAAHpk4xqAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAKVQTFRFqsZtvNaEvdaFvteHvteIv9iJv9iKwNmMwdmNwdmOwtmOwtqPw9qQw9qRx92YyN2ZyN2ayN6byd6byd6c0eOq1ua01+e22Oe33uvD4e3I4u3J4u3K4+7M5O7N5O/O6PHW7fTe7/Xi7/bj8Pbk8/jp8/jq9Pjq9Pjr9Pns9fns9fnt9vrv+Prx+Pvy+Pvz+fvz+vz1+/34/P36/f78/v79/v/+////1tsuPQAAAQJJREFUKM+lkN1SwjAQRveUAqVqFaVVKFB+RBFaEEj2/R/Ni1AmqJ1xxu8mc3I2uzsRERGRZYRIDCKAiLiT4MkxUJ+BQQTMw7lOLpYcFGHfVxAslAiM3sBvcIkIMNbK2vBMCnCT5o4sHxrQWTtqaUa3XPzS5So/BlxTaGylk5q0B8ynjobPwAB1dGBAWrB1tIpuDwUYR0lFF3rnSma7iEzb9bxkfRw1TPeXpiF/U8nw/XRaj+6/q9ZMd1kE3azURdtXia3iujou9dFTKxu5+1Rf6JiNpw57eP3sp1oEwPboqaFmcLcpAvcy99fIddlzLaO5Tq+XD8dWTVUZtZPwn7/RmC+jnBV6oPkZWgAAAABJRU5ErkJggg==) -1px -1px no-repeat;    color: #d7ead7;}/*右侧特别推荐*/.git_textbanner a.style01, .git_textbanner a.style01 h2 {    color: #91bff1;}.git_textbanner a {    display: block;    background-color: #1a313d;    border: 1px #535353 solid;  width: 320px;    margin: auto;}.git_textbanner a p {    margin-bottom: 0;    padding: 0 20px 5px;}/*登录可见的字样*/.e-secret legend {    display: none;}</style><link rel="icon" type="image/x-icon" href="https://www.iiicg.com/wp-content/uploads/2018/04/2018042102510023.png"><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?e5099790153bc55ee89d636e4e083bcf";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script><title>Photogrammetry 完全指南  </title><script>window._deel = {name: '',url: 'https://www.iiicg.com/wp-content/themes/Git-alpha', ajaxpager: '', commenton: 0, roll: [0,0]}</script><!--[if lt IE 9]><script src="https://cdn.bootcss.com/html5shiv/r29/html5.min.js"></script><![endif]--><script src="./Photogrammetry 完全指南_files/share.js.下载"></script><link href="./Photogrammetry 完全指南_files/saved_resource" rel="styleSheet" type="text/css"></head><body class="post-template-default single single-post postid-881 single-format-standard logged-in custom-background"><section class="container"></section></body></html></div>                <div class="toptip" id="callboard"><ul style="font-size:16px;margin-top: 2px;">        </ul></div>    <div class="content-wrap"><div class="content"><article class="article-content"><p><span style="font-size: 12pt;">原文地址 <a href="https://80.lv/articles/full-photogrammetry-guide-for-3d-artists/" target="_blank" rel="nofollow" data-original-title="" title="">https://80.lv/articles/full-photogrammetry-guide-for-3d-artists/</a></span></p><p><span style="font-size: 12pt;">本文为有道翻译+人工修改，有些地方可能翻译不准确，请大家及时在评论里反映。</span></p><hr><p class="name"><span style="font-size: 14pt;"><strong><a href="https://www.artstation.com/ssh4" target="_blank" rel="noopener noreferrer" data-original-title="" title="">Vlad Kuzmin</a> 分享了很多摄影测量的技巧。学习如何扫描真实世界的物体，清理和渲染。.</strong></span></p><p>–</p><p>–</p><p style="text-align: left;" align="center"><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">指定计划</span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 一个好的摄影测量的成功取决于正确的计划。这意味着不仅仅是充满电的相机电池和相机三脚架。而且不只是良好的阴天或合适的工作室扫描设置。在你开始疯狂拍摄之前，首先你需要估计一下你的目标是如何拍摄的。如果你在室外拍摄，你需要检查你的物体，光线条件和物体周围的可用路径</span>。</p><p align="center"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/001_Planning.jpg" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89153" src="https://cdn.80.lv/80.lv/uploads/2018/03/001_Planning.jpg" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="689"></a></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 在你计划拍摄的物体周围有足够的移动空间是很好的。你应该在物体周围有 3 到 5 米的可用空间，为了拍摄特写镜头，你需要达到至少比物体高 50cm(物体高度为 3 米)。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">预习</span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 良好的扫描练习:在物体周围至少有一个每 10 度的增量(大概一圈能拍 36 张图)，整个物体要包含在图像中。为了获得更好的结果，您可以从不同的角度创建更多的循环（一圈）。这些图像给摄影测量软件一个“基本框架”。这个“框架”将被用于更近距离拍摄的对齐和深度计算。&nbsp;&nbsp;</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 接下来就是中距离和近距离镜头:如果第一个距离在 3 米以外的物体，中距离是 1.5 米，近距离是 50 厘米。中距离镜头要衔接上近距离和远距离。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 在远距离图像中，一枚硬币看起来像一个点，在近距离图像中，硬币是清晰的细节。特征(连接点)检测算法不能识别一个图像中的点和其他图像中的一个大硬币。这就是为什么中间步骤是必要的。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 在中距和近距镜头，我们需要记住所有的表面。扫描对象的每边都需要拍摄:背后,上面,<span class="op_dict_text2">较低的</span>,内侧,等等,每一个点的每个表面都需要至少 2 – 3 个图片,一个正对的和两个轻微的偏 10°-15°。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 我看过很多由爱好者拍摄的照片，他们的膝盖、腋下、椅子的底部、桌子的底部、屋顶的底部，甚至雕塑的顶部(很常见的问题)都被完全遗忘了。<br></span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/002_Planning.jpg" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89157" src="https://cdn.80.lv/80.lv/uploads/2018/03/002_Planning.jpg" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="411"></a></span></p><p align="justify">&nbsp;&nbsp;&nbsp; <span style="font-size: 12pt;">不要忘记<a href="https://medium.com/@ssh4/overlap-what-is-it-d7765352d968" target="_blank" rel="nofollow" data-original-title="" title="">适当的重叠</a>:每个镜头都需要与下一个镜头重叠至少 60%(80%以上甚至更好)。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 好的摄影测量三维扫描需要多少张图片? <a href="https://medium.com/@ssh4/where-and-how-many-images-required-for-good-photogrammetry-3d-scan-a5481b3b7bef" target="_blank" rel="noopener noreferrer" data-original-title="" title="">A post with advice on taking images for photogrammetry scan.</a></span></p><p align="justify"><span style="font-size: 12pt;"><strong>&nbsp;&nbsp;&nbsp; 避免</strong>全景拍摄(相机停留在三脚架上，而你只旋转相机)。摄影测量软件可以看到一个全景图像。这样的图像没有视差的变化，因此没有深度信息来计算网格的细节。或者软件不能正确地对齐这些图像。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 当你有一个关于物体的基本计划并且已经知道需要额外注意的物体的部分时，你就可以开始拍摄了。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 拍摄,小侧步,拍摄,小侧步,拍摄…完成循环后,举起相机,开始下一个循环等等。</span></p><p align="justify"><span style="font-size: 12pt;">在一些光照条件下，例如，一个洞穴中的物体和一个比其他颜色更深的物体，最好使用其他的技术。从下面拍摄，再将摄像机向上移动，以此类推。在那之后，做一个小的台阶，重复垂直运动，但从上到下。从下面到顶部。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 如果你是这样拍摄的，你可以调整相机的设置，这样物体的任何背光的一面都不会曝光不足，光线也不会曝光过度。在此过程中，您应该避免在相机上更改 ISO 设置。具有不同 ISO 设置的图像往往有不同的“噪点模式”或噪点等级。不同 ISO 的图像需要分别进行预处理。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 你应该始终遵循物体的形状和曲线。拍摄需要是正对着，或者仅仅是与表面的一个轻微的角度。</span></p><p align="center"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/003_Shooting_fix.jpg" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89163" src="https://cdn.80.lv/80.lv/uploads/2018/03/003_Shooting_fix.jpg" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="775" height="1024"></a></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 当你知道你有所有必要的图像，比如雕塑头的顶部，背面，向下看的表面等等，现在是最后的“绝杀”镜头的时候了。这些可以是最复杂的表面的随机照片，或者是脸部、眼睛、耳朵、手掌等精细细节的表面，这样做是为了确保我们没有遗忘任何东西。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 我们需要记住，图像需要尽可能的清晰。此外，场地的深度需要尽可能大。如果你使用的是单反相机或无反光镜相机，你应该已经知道如何实现这一点。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 你甚至可以使用一部好的智能手机。iPhone 有一个很好的摄像头，可以用于高分辨率的摄影测量和亚毫米分辨率。只有获得良好的纹理是后处理中更困难的一步。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 我知道从 40-90 张图片中得到好的结果总是很棒的，你会从更多的图片中得到更好的结果。如果你使用智能手机，你可以使用 300-500 张照片或两倍以上的相机。少数图像不是我们的选择。拍完所有必要的照片后，是时候回到办公室了。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">删除旋转标签</span></strong></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 几乎所有的照片编辑软件都会根据你使用的相机旋转自动旋转图像。你会在屏幕上看到“正确的方式”。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 通常,对于现代摄影测量软件来说，旋转图片不是一个问题,但垂直用相机拍摄的照片可以旋转 90°和 270°,被视为不同的透镜组,并不总是可取的。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 这就是为什么通过使用 ExifTool 或 ExiftoolGui 来删除摄像机旋转 EXIF 标记是明智的。</span></p><p align="justify"><span style="font-size: 12pt;">exiftool –Orientation=1 -n image.ext 或</span></p><p align="justify"><span style="font-size: 12pt;">exiftool –Orientation=1 –n *</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 对于批处理，从选定文件夹中的所有图像中删除此标记。</span></p><p align="justify"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/EXIF-toolGUI.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89176" src="https://cdn.80.lv/80.lv/uploads/2018/03/EXIF-toolGUI.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="624"></a></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 如果你的专用相机只用于摄影测量，你可以在相机设置中禁用图像旋转。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">预处理</span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 如果我告诉您任何预处理的数据集总是比未处理的要好呢?</span><span style="font-size: 12pt;">嗯，你的相机很好，你的照片在 Instagram 上看起来很棒。是的，可以用原生的 iPhone 相机应用程序拍摄并进行适当的扫描。</span><span style="font-size: 12pt;">但是，最好是在原始的和预处理的图像中进行拍摄，以获得更好的对齐、网格和纹理。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 人类的眼睛比任何摄影测量软件都能看到更多的细节。这就是为什么我们需要应用预处理-我们将帮助摄影测量软件识别细节，特别是在阴影和照明区域。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 我个人的偏好是在 Adobe Photoshop 中使用 CameraRAW。Lightroom、DxO Optics,、Affinity Photo 或其他免费或付费的图像处理工具也可以使用。</span><span style="font-size: 12pt;">我们需要修复曝光，减轻阴影部分，使照明区域变暗。我们也可以去掉色差。</span><span style="font-size: 12pt;">去除噪点并锐化图像。但是要小心，因为图像不能以任何方式被扭曲。</span></p><p><span style="font-size: 12pt;"><span style="color: #ff0000;">&nbsp;&nbsp;&nbsp; 纠正镜头扭曲是严格禁止的</span>!图像处理工具的校正并不是摄影测量的校正。</span><span style="font-size: 12pt;">你需要强行取消相机、Lightroom、DxO 或其他你使用的照片编辑软件的镜头畸变校正。否则，您将会损坏执行正确的摄影测量过程所需的数据。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span style="font-size: 12pt;">对于大多数户外扫描，我使用这些设置。是的,他们是强大的</span></p><p><span style="font-size: 12pt;">曝光: 从 +0.0 到 +1.5</span><br><span style="font-size: 12pt;"> (取决于光照条件。通常情况下，图像会被曝光不足。)</span></p><p><span style="font-size: 12pt;">Lights: 从 -50 到 -100</span><br><span style="font-size: 12pt;"> Shadows: 从 +50 到 +100</span><br><span style="font-size: 12pt;"> Lights: 从 -50 到 -100</span><br><span style="font-size: 12pt;"> Blacks: 从 +20 到 +100</span></p><p align="justify"><span style="font-size: 12pt;">你可以添加更多的细节对比清晰,抖动,和 Dehaze（除雾）…低 ISO 图像,默认的降噪和锐化就足够了。但是“细节”设置最好设置为零。</span></p><p align="center"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/CameraRaw.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89175" src="https://cdn.80.lv/80.lv/uploads/2018/03/CameraRaw.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="781"></a></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 我更喜欢通过 Adobe Photoshop 进行批处理图像处理，并使用动作脚本与 CameraRAW 打开图像。该脚本可以运行一些额外的过滤器、操作或插件。我可以稍微调整一下每个数据集的脚本。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 预处理的基本思想是在阴影和光线中增加细节的可视性，增强细微对比度。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 注意:所有的过程都需要 16 位，并且输出 16 位 tiff/png。</span><span style="font-size: 12pt;">导出也可以是 8 位 JPG, 100%的质量。16 位就足够了(是的- 如果你知道数学和图像处理的基础知识，8 位 JPG 图像可以提供 16 位纹理)。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">REALITYCAPTURE:</span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 如果这个词让你感到害怕那我很抱歉，但是没有其他的摄影测量工具能替代<a href="https://www.capturingreality.com/" target="_blank" rel="noopener noreferrer" data-original-title="" title="">RealityCapture.</a>的能力。不仅因为它的速度快，而且与其他工具相比，更高的模型细节和很低的硬件要求。所有的计算，除了对齐相机 RealityCapture 使用 out of core。想象一个 30 亿的多边形网格在 16Gb 内存!这种能力也适用于非企业用户。</span></p><p><span style="font-size: 12pt;">也许价格会有点高: 3 个月为 99 欧元(33 欧元/月)。但是在一些国家，这就像在餐馆吃饭一样（…………）。</span></p><p><span style="font-size: 12pt;">其他竞争对手（同类软件）的成本就像喷气飞机，或者像糖蜜一样慢（-.- 小心得罪人）。</span></p><p><span style="font-size: 12pt;">这就是为什么我要使用 RealityCapture，因为我想本周从扫描中获得所有可能的细节。</span></p><p><span style="font-size: 12pt;"><span style="color: #ff0000;">注意</span>:即使 16Gb 内存足够，32Gb 的内存更适合工作。</span></p><p>&nbsp;</p><p align="right"><span style="font-size: 10pt;"><em>– Dude, I don’t like cats!</em></span><br><span style="font-size: 10pt;"> <em> – You just don’t know how cook them!</em></span></p><p align="justify"><span style="font-size: 12pt;">为什么 RealityCapture 会带来坏的结果的两个原因:</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp; 第一个原因——你不知道如何“烹饪”RealityCapture! （使用）</span><br><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 第二个原因——你不知道如何“拍摄”图像!</span></p><p align="justify"><span style="font-size: 12pt;">第二个是人们使用 RealityCapture 获取不良结果的主要原因。<span style="color: #ff9900;">垃圾进</span>，<span style="color: #ff9900;">垃圾出</span>!</span></p><p align="justify"><span style="font-size: 12pt;">如果你有一个好的数据集，结果应该是不可思议的。你可以用一部 iPhone 6 相机，在高度为 3 米的物体上达到 0.5 毫米的分辨率。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 你可以在开发人员的网站上，或者在 SketchFab 博客上找到 RealityCapture 的基本工作流程。你也可以在应用程序本身找到更多的建议。帮助文档是最有好的，您可以很容易地找到对任何选定工具的解释。</span><span style="font-size: 12pt;">RealityCapture (RC)提供的是对所有摄影测量步骤的完全控制。默认设置足以从良好的数据集获得良好的结果。然而，不是完美的数据集需要一些微调，这可以通过为每个数据集裁剪必要的设置来实现。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">REALITYCAPTURE—设置</span></strong></span></p><p><span style="font-size: 12pt;">缓存位置:</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 在默认情况下，RC 使用一个系统临时文件夹，用于所有临时文件(可以从 120-150Gb 到平均 12-24Mpx 图像数据集)。一旦项目中的文件被使用，或者您同时使用多个项目，最好将缓存位置设置为专用的大型 SSD (512Gb 或更多)或快速 HDD。</span><span style="font-size: 12pt;">RC 的 90%或所有操作 out of the core，所有临时文件都被写入到缓存目录中。这些临时文件可以在稍后的步骤中被 RealityCapture 重用，并且可以大大加快计算速度。</span><span style="font-size: 12pt;">我的建议是将缓存位置设置为另一个驱动器，例如，Z:/RC_TEMP。在此之后，需要重新加载 RC。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">相机使用 EXIF 分组</span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 没有理由不使用这个设置。启用分组可以帮助您避免错误的相机和镜头判断。RealityCapture 通过一个镜头组中的所有图像来计算这些参数。我强烈推荐这款“带主镜头相机”的转盘扫描。对于多摄像机设备来说，分组是不必要的。</span></p><p><span style="font-size: 12pt;">有两种方法对图像进行分组。</span></p><p><span style="font-size: 12pt;">1:选择 1D view 左上角的“Image”分支，在窗口上显示，按 group。</span></p><p>&nbsp;</p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="./Photogrammetry 完全指南_files/2.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89185" src="https://cdn.80.lv/80.lv/uploads/2018/03/2.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="318" height="69"></a></span></p><p><span style="font-size: 10pt;"><span style="font-size: 12pt;">2: 在图像导入上启用分组。</span><br></span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/002_Settings.jpg" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89158" src="https://cdn.80.lv/80.lv/uploads/2018/03/002_Settings.jpg" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="838" height="1024"></a></span></p><p><span style="font-size: 12pt;">图像重叠:</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 它定义了被拍摄的图像如何覆盖扫描对象。默认情况下，这将设置为 Medium。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 如果数据集的所有图像至少有 70-80%的重叠与最近的图像重叠，则可以设置中重叠。这些重叠设置对大多数业余爱好者来说都是不好的，因为它需要 800-1000 张图片，在简单的形状之间没有空隙。如果您有一个小的数据集，它很可能会被分成许多组件(连接的和对齐的图像组)。这就是为什么在大多数情况下，低重叠是首选。</span></p><p><span style="font-size: 12pt;">传感器灵敏度:</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/003_Settings.jpg" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89161" src="https://cdn.80.lv/80.lv/uploads/2018/03/003_Settings.jpg" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="713"></a></span></p><p><span style="font-size: 12pt;">它定义了如何精细和有多少特性(物体的唯一位置)RC 将尝试检测。</span></p><p><span style="font-size: 12pt;">例如:对于丰富的花岗岩纹理，你可以使用低灵敏度。对于微妙的白色大理石纹理，你将不得不使用高灵敏度。</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/004_Settings_Sens.jpg" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89167" src="https://cdn.80.lv/80.lv/uploads/2018/03/004_Settings_Sens.jpg" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="341"></a></span></p><p align="justify"><span style="font-size: 12pt;">超高灵敏度很少被使用。它可以用于工作室里的面部或身体扫描。最好不要设置比要求更高的灵敏度。</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="./Photogrammetry 完全指南_files/005_Settings_Cons.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89170" src="https://cdn.80.lv/80.lv/uploads/2018/03/005_Settings_Cons.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="314" height="390"></a> <span style="font-size: 12pt;">控制台视图:</span><br></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 在一些 RC 窗口中，我建议启用控制台视图。它可以显示一些有用的信息，当我们需要联系支持或其他专家时，它可以提供帮助。</span></p><hr><p align="center"><span style="color: #00ffff;"><strong><span style="font-size: 14pt;">REALITYCAPTURE 工作流程</span></strong></span></p><hr><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">对齐</span></strong></span></p><p align="justify"><span style="font-size: 12pt;">如果这是一个较老的工程，或者我们不确定分组的图像，我们可以点击左上角的“Images”，点击“Clear Calibration Groups”- Ungroup 和“Group Calibrations w.r.t. EXIF”-Group。</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="./Photogrammetry 完全指南_files/005_Settings_Group.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89171" src="https://cdn.80.lv/80.lv/uploads/2018/03/005_Settings_Group.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="566" height="247"></a></span></p><p><span style="font-size: 12pt;">现在，当所有的图像都被 EXIF 分组时，改变图像重叠到低，并检查所需的检测器灵敏度。接下来，我们可以运行 alignment。根据图像的数量和大小，这可能需要几分钟。</span></p><p><span style="font-size: 12pt;">当在 RC 中进行任何操作时，我们可以在 console 视图中看到:</span></p><p><span style="font-size: 12pt;">如果我们使用默认设置，每个图像有 40000 个特征，在控制台视图中，我们看到一些图像的特征小于 40000 个，这通常指向图像质量的问题。稍后，我们可以确定这些图像没有正确对齐，丢失或出现问题的原因是在网格或纹理中。</span></p><p><span style="font-size: 12pt;">我们还可以看到这个过程的详细时间报告。</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/001_Align_Cons.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89151" src="https://cdn.80.lv/80.lv/uploads/2018/03/001_Align_Cons-1024x326.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="326"></a></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 如果我们正确地拍摄了数据集，99%或所有的图像都在第一步中对齐。由于图像的问题，只丢失了一些图像。不好的图像很可能是那些比我们在 console 视图中看到的更小的检测功能。</span><span style="font-size: 12pt;">如果我们在左窗口中看到不止一个组件，但是我们的数据集很好，那么 RealityCapture 可以将所有图像作为下一个步骤中的一个组件对齐。我们需要删除小的组件，只留下最大的，再对齐。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 在这一点上，RC 将重复用第一步中检测到的特性(从缓存目录中存储的数据)，优化主组件的摄像机位置，并为我们在第一个对齐步骤中使用的其他组件找到合适的位置。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 如果必要的话，可以重复几次。即使是一个组件，RealityCapture 也会改进相机定位和镜头设置，从而提高质量。</span><span style="font-size: 12pt;">如果每次对齐后，您都可以看到相同数量的独立组件和相同的图像计数，这意味着我们需要使用手动控制点。</span></p><p>&nbsp;</p><p align="justify"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/001_Align_Components.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89150" src="https://cdn.80.lv/80.lv/uploads/2018/03/001_Align_Components.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="704" height="710"></a>&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-size: 12pt;">在 RC 中使用手动控制点和组件，是一个单独的任务。例如，这是用来扫描巨大的物体，比如建筑物和城堡，你可以扫描内部和外部。控制点工作流是一种单独的技术，它不适合本教程，因为它需要更多的时间来解释。</span><br></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 控制点(CP)工作流程的基本思想:</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 在一个小的组件中，创建大约 3-4 个控制点，通过从控制点窗口拖动到选定的图像，将它们至少放置在 3-4 个图像上。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 为了细化它们的位置，点击一个放置的 CP，在保持这个点的同时，使用缩放轮，调整缩放级别，更精确地放置点，然后释放。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 在至少 3 到 4 个图像上放置最大组件的相同控制点。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 左右箭头键可用于在数据集中的图像之间切换。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 在选定的 2D 视点的场景选项卡中启用 Residuals ，将显示当前 CP 到正确位置的线，由当前组件摄像机对齐估计。</span></p><p>&nbsp;</p><p style="text-align: center;" align="justify"><span style="font-size: 10pt;">一段由开发者制作的短片，展示了控制点的工作流程:</span></p><p><a href="https://youtu.be/3ojj3q4S2o4" target="_blank" rel="nofollow" data-original-title="" title="">https://youtu.be/3ojj3q4S2o4</a></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 完成此操作后，删除小组件并再次运行对齐。如果在数据集中没有更多的错误，RC 将合并并对齐所有的摄像机与一个组件。如果您不再需要这些旧组件，您也可以删除它们。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 现在，几乎所有的图像都对齐在一个组件中。我们终于可以改进相机的对齐方式。为此，我们可以对所有图像进行分组，并运行最终对齐。在这一步骤中，RC 将把所有的相机都当作不同的镜头来计算，并根据不同的变焦或传感器/镜头从光学稳定(如果你使用它)来调整小的偏差。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 在此步骤中，我们可以减少最小的再投影误差。默认情况下是 2px。虽然对于大多数数据集来说，它已经足够好了，但我个人的偏好是将相机改进到至少 1px 的错误。把它设置得更低，将使平均值和中值误差更加精确。更少的错误-更好的网格，更好的网格-后面就更少的工作。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">MESHING&nbsp; 构建模型<br></span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 首先，我们需要通过定义一个地平面来对齐我们的扫描到地面。视图之间的切换可以通过键盘上的 4、6 和 2 个数字键来完成，也可以通过场景选项卡完成。接下来，我们需要定义重建区域。最好设置尽可能小，以适合扫描对象或扫描区域。</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/001_Reconstruction_Region.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89154" src="https://cdn.80.lv/80.lv/uploads/2018/03/001_Reconstruction_Region.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="769"></a></span></p><p><span style="font-size: 12pt; color: #ff0000;">记得保存</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 接下来，我们可以运行正常或高模式的网格。</span><span style="font-size: 12pt;">如果您在正常的细节模式下有默认设置，RC 将计算从 2x 向下采样的图像的深度映射。高细节模式使用图像而不需要向下采样。RealityCapture 可以将细节重构到 0.25px，这意味着正常模式下的网格有时是足够的。</span><span style="font-size: 12pt;">如果你确信数据集是干净而清晰的，通过在高细节模式下进行网格划分，你会得到更多真实的细节。然而，这需要更多的时间。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 对于一个测试,我们可以设置 4 x down-sample 正常模式的细节。这将给出足够的细节来对最终的网格质量进行高效的估计，并且将会很快完成(在适当的硬件上 5 – 10 百万网格需要 20 – 30 分钟)。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 对于 PC 硬件来说，最大的压力是深度图的计算。此时，GPU、CPU 和 SSD/HDD 使用率可以达到 100%。并且由于系统不能控制 GPU 优先级，而这是在进行的同时，您将不能使用 PC(在夜间运行，特别是在高模式下运行时更好)。</span></p><p><span style="font-size: 12pt; color: #ff0000;">永远别忘记保存！</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/RawMesh.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89181" src="https://cdn.80.lv/80.lv/uploads/2018/03/RawMesh.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="624"></a></span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-size: 12pt;">你可以从这里几种不同的方式。许多用户选择将一个网格的数量减少到 1-1.5 百万多边形，并将其从 RC 直接上传至 SketchFab。但是，从任何摄影测量应用程序中，一个原始的、未被修改过的网格都是不完美的。这就是为什么我们需要修复原始网格。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">SIMPLIFYING&nbsp; 简化模型<br></span></strong></span></p><p><span style="font-size: 12pt;"> 在高分辨率网格中，一个 500-700px 的图像网格的普通多边形数约为 100-200 百万多边形。可以肯定地说，我们不需要所有的这些。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 从 16mln 的多边形，4K 材质可以将微细节存储在一个法线贴图上，8K 到大约需要 67 百万的多边形。为了得到最好的结果，16 百万多边形网格细节需要存储在 8K 法线贴图上。这意味着我们可以把一个原始的 100-200 百万多边形网格简化到 8-16 百万的多边形，没有任何问题。decimation 算法会保留这些锋利的细节，我们不需要担心这个。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 为了导出网格，OBJ 是最通用的格式。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">修复原始模型的错误拓扑 (旧方法)</span></strong></span></p><p><span style="font-size: 12pt;">如果您使用的是外部软件，如 ZBrush，您可以跳过这一步。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 在原始网格中非常常见的问题是，从 decimation 步骤后或 T-顶点（零面积多边形）中出现的孔和 non-manifold 的边/顶点（交叉）。因为 RealityCapture 很少有 twisted 相交的多边形，所以我们只需要填充这些孔。为此，我们可以使用 MeshLab 或 MeshMixer。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 在 MeshLab – Close Holes。在某些情况下，有两个多边形的洞，中间只有一个顶点，而 MeshLab 不能关闭这个孔。您将需要删除一个或两个多边形并再次运行该工具。为了消除 t 顶点，我们需要运行 tool «Remove T-vertices with edge flip»，值为 10-20。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 在我们关闭所有的孔并固定所有的 t 顶点后，我们可以将网格导入到一个曲面雕刻 app 中，我个人喜好是 3d coat。这个应用程序可以使用不固定的网格，但是最好在导入之前修复拓扑错误。</span></p><p>&nbsp;</p><p><span style="font-size: 10pt;"><a href="http://3dcoat.com/home/" target="_blank" rel="noopener noreferrer" data-original-title="" title=""><strong><span style="font-size: 14pt; color: #99cc00;">3D-COAT</span></strong></a></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 这个应用程序对于 3D 扫描网格来说是非常棒的。与 ZBrush 相比，它有一个线性的工作流，工具是工具，对象是对象。使用简单,你不需要谷歌如何导入 OBJ 文件,并发现你的对象是一个工具,你需要一个工具来修复工具内的工具…</span></p><p align="center"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="./Photogrammetry 完全指南_files/xzibit.jpg" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89184" src="./Photogrammetry 完全指南_files/xzibit.jpg" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="554" height="369"></a></span></p><p><span style="font-size: 10pt;">One important note: Because we have already fixed the mesh topology, we won’t have to import it as “repair scanned mesh”. This is usually slow and requires watertight meshes.</span></p><p><span style="font-size: 10pt;">We need to only import the mesh for SURFACE Sculpting. （什么鬼）<br></span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/3DCoat_Import.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89165" src="https://cdn.80.lv/80.lv/uploads/2018/03/3DCoat_Import.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="803" height="424"></a></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 另一件值得注意的事情是:3D-Coat 的体素雕刻令人惊叹。但是我们必须避免所有 Surface&lt;-&gt;Voxel 转换和在 3D-Coat 中减面。该操作将通过一些快速筛选的泊松网格重建算法来破坏我们的所有微细节。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 3D-Coat 在动态网格镶嵌上有巨大的优势(你可以有时也需要禁用)。它叫做“消除拉伸”。这将增加网格分辨率，只在你工作的区域。其他的网格部分保持不变。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 当导入表面雕刻时，你会得到一个提示，告诉你你需要启用“import without voxelization”，respect negative volume 和保留旋转坐标。您将需要按自动缩放，并按下应用。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 在此之后，另一个弹出对话框将显示，我们需要选择 Yes 来存储原始的缩放、旋转和 etch，它将在 3D 空间中存储原始的网格信息。这是不应该改变的，或者以后当我们将网格导入 RC 作为一个固定的网格时，它不会和原来的网格在同一个地方。</span></p><p align="center"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/3DCoat_Import2.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89166" src="https://cdn.80.lv/80.lv/uploads/2018/03/3DCoat_Import2.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="796"></a></span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">SCULPTING 雕刻<br></span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 这是工作中最有创意的部分。3 d-coat 提供了一系列不同的工具。最常用的是填充、压平、冲、带 alphas 的笔刷，以及有无动态镶嵌。</span></p><p><span style="font-size: 12pt;">3DCoat 网格雕刻基础:</span></p><p><span style="font-size: 12pt;">Simple Brush – rise; Fill – fill pits or canals; Flat – flatten hills, etc.</span></p><p align="justify"><span style="font-size: 12pt;">When holding the CTRL button pressed, most tools are reversed.</span></p><p align="justify"><span style="font-size: 12pt;">Brush – dig; Fill – smooth flatten hills (fill them from the other side of the polygons); Flat – rise (careful with this), etc.</span></p><p align="justify"><span style="font-size: 12pt;">A special CTRL + SHIFT will switch any tool to Relax polygons. This works like smooth, is faster and does not increase the polygon density.</span></p><p align="justify"><span style="font-size: 12pt;">Another useful tool is the Tangent smooth tool. It can relax edges between big and small polygons but retain a shape of a surface.</span></p><p align="justify"><span style="font-size: 12pt;">We can fix big polygons with the “Draw” tool with default smooth “alpha”, set depth to 0.5 or less and enable “remove stretching”. Simply paint over the big polygons with or without CTRL and these will be subdivided. Next, select a “random” alpha and increase the depth up to 1 to add some noise similar to a correctly reconstructed surface.</span></p><p align="justify"><span style="font-size: 12pt;">If we have some shifted surface, we can fill the cracks with the Fill tool, or flatten it with CTRL + Fill. Or even smooth them with relaxation. After that, recover the original noise with “Draw” tool with alphas.</span></p><p align="justify"><span style="font-size: 12pt;">A video explaining the basics of how this works can be seen here:</span></p><p><iframe src="./Photogrammetry 完全指南_files/eHLfn-1vwTg.html" width="500" height="281" frameborder="0" allowfullscreen="allowfullscreen" data-mce-fragment="1"></iframe></p><p align="justify"><span style="font-size: 10pt;">&nbsp;&nbsp;&nbsp; &nbsp; <span style="font-size: 14pt;">修正的基本思想 :从弱表面的大多边形增加网格分辨率。解决定位错误。找回丢失的部分。</span></span><span style="font-size: 14pt;">在固定好形状后，添加一些与原始未接触表面类似的小噪点细节(以防你扫描的是有机或石头物体)。对于光滑的表面来说，噪点是不必要的，但是雕刻需要注意尖锐的边缘和平坦的表面。有时，您可以将被扫描的对象分割成多个部分，分别恢复各个部分，然后将其合并回去。</span></p><p align="justify"><span style="font-size: 14pt;">&nbsp;&nbsp;&nbsp;&nbsp; 经过所有这些步骤，我们获得了一个“干净”的高分辨率网格。这需要作为 OBJ 导出。</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/snapshot04.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89182" src="https://cdn.80.lv/80.lv/uploads/2018/03/snapshot04.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="565"></a></span></p><p align="justify"><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">QUALITY CHECK 检测质量<br></span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 我们会检查我们干净的网格的质量。与最开始的原始模型一样，我们可以在 MeshLab 或 MeshMixer 中检查错误。检查相同的错误:孔、相交的多边形、t 形顶点以及在雕刻步骤中可能出现的更多错误。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 然后导出干净的模型。</span></p><p>&nbsp;</p><p align="justify"><strong><span style="font-size: 14pt; color: #99cc00;">IMPORT BACK TO REALITYCAPTURE&nbsp;&nbsp; 导回进 REALITYCAPTURE<br></span></strong></p><p align="justify"><span style="font-size: 12pt;">现在我们需要从 reconstruction 选项卡导入干净的模型到 RealityCapture。如果我们工作中仔细，干净的模型将被放置在原始模型的位置。如果模型在位置、方向或形状上有许多较大的差异，那么摄影测量软件将无法正确地计算纹理。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">TEXTURING&nbsp; 生成贴图纹理<br></span></strong></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 接下来的一步是将已清理的高分辨率网格进行纹理处理。</span><span style="font-size: 12pt;">在高度 2-3 米的物体中，产生 16k 的纹理分辨率是很好的，之后会被还原成最终的 4k 或 8k 纹理。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; RC 有一个 16k 分辨率和 UV 展开的一个“maximal textures count”，导入模型默认是 16k 纹理分辨率。您首先需要检查这些设置。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; 对于提高贴图效果，我们需要将外环的照相机的纹理权重改为非常小的值。</span><span style="font-size: 12pt;">使用相机套索工具，选择这些外环相机，或选择所有中距离和近距离摄像机，并反转选择。在图像属性将重量改为 0.01(1%)或更少。</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/Weight.jpg" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89183" src="https://cdn.80.lv/80.lv/uploads/2018/03/Weight.jpg" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="356" height="276"></a></span></p><p><span style="font-size: 12pt;">接下来，我们可以运行 Unwrap，然后是 Texturize。或者只是纹理化(如果模型没有 UV 贴图，它会自动打开)。在此步骤中，RC 使用 GPU，这样您的系统可能不会响应高的 GPU 负载。完成后，我们可以简单的导出干净、高分辨率的模型和纹理。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">DECIMATION&nbsp;&nbsp; 抽取<br></span></strong></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 如果我告诉你所有自动或半自动的 quad 重新拓扑工具都是坏的呢?</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 简单的低多边形拓扑规则:低多边形网格边缘需要尽可能地跟随高分辨率网格。但是凹陷的边，<span class="op_dict_text2"> 眼状</span>，尖锐的边缘，所有这些都是自动重新拓扑工具的问题。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 当然，你可以用向导。这肯定会增加最后的低多边形网格质量。你使用的指导越多，完成工作所需的时间就越多。有时,太多的指导和方法会失败。在许多情况下，手动的重新拓扑比使用自动的方法更快地工作。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 所有的实时引擎都使用三角形，如果我们不需要动画(morph)扫描，静态对象如石头，雕塑等，根本不需要四边面。</span><span style="font-size: 12pt;">我们使用 MeshLab 的 Quadric Edge Collapse Decimation ，将高模减成低模，抽取 50%，从 10 百万到 5 百万等等。</span></p><p align="center"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/MeshLab.jpg" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89177" src="https://cdn.80.lv/80.lv/uploads/2018/03/MeshLab.jpg" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="568" height="615"></a></span></p><p align="justify"><span style="font-size: 12pt;">不要担心，因为这一步不需要太多的关注。在设置中设置 0.5，并按“OK</span></p><p align="justify"><span style="font-size: 12pt;">通过这种方法，我们将保留大部分细节，而不是简单地将 10 百万转换为 30k 多边形网格。或者通过任何四种自动重拓扑结构。</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/30K.jpg" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89173" src="https://cdn.80.lv/80.lv/uploads/2018/03/30K.jpg" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="680"></a></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 当大量使用 100-150k 多边形时，最好检查网格是否存在拓扑错误，如果存在的话，修复它们。如果你有高分辨率的模型，高分辨率模型上可以有小的桥梁或尖峰，当边缘坍塌时，这些可以形成自我交叉的多边形。这可能导致在最后的 decimation 步骤中出现问题。这在 MeshLab，MeshMixer 或者其他软件中很容易修复。100k 多边形网格不是一个需要处理的问题。模型的问题都修复完后，可以再抽取 50%，直到 50-75k，后面使用.</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 如果物体是一个简单的，均匀的扫描，像石头，并且它没有我们想要保存的部分，我们可以将它抽取 1 到 2 次并且得到一个 10k-30k 多边形网格。如果我们的物体是一个雕像或一个底座，我们可以使用选择性抽取。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 选择重要的细节部分：脸，手掌、手指…我们可以用粗糙的选框工具选择,和画笔为多边形选择工具选择。</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/MeshLabSelect.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89178" src="https://cdn.80.lv/80.lv/uploads/2018/03/MeshLabSelect.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="624"></a></span></p><p><span style="font-size: 12pt;"> 在我们得到所有想要保留的部分后，我们可以应用选择反向。并且只对这些部分使用 50%的 decimate，只使用“Simplify only selected faces”选项。如果这是对一个基座上的雕像扫描，我们可以再次选择基座，并将其抽取 50%。你可以选择底部的底部，并再次将其删除，特别是如果在扫描中看不到的面。</span></p><p>&nbsp;</p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/MeshLabSelectDecimate.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89179" src="https://cdn.80.lv/80.lv/uploads/2018/03/MeshLabSelectDecimate.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="624"></a></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 我们应该对任何拓扑错误(包括 T 顶点)进行网格的最后检查。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">UV</span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp; 许多人喜欢四边形的一个主要原因是，循环边缘可以更快的展 UV。抽取过的模型都是三角面，但这不是问题。3D-Coat 非常适合扫描，不仅是因为动态细分。但是因为它有一个神奇的 UV Path 工具。可以“绘制”Path，并且它们的流可以很容易地调整。因此，我们在 3D-Coat 中打开低模 使用“UV map mesh”。</span></p><p style="text-align: center;"><span style="font-size: 10pt;">这里有一个视频解释了 UV Path 的工作原理：</span></p><p>&nbsp;</p><p><iframe src="./Photogrammetry 完全指南_files/_lhjVcrNXUY.html" width="500" height="281" frameborder="0" allowfullscreen="allowfullscreen" data-mce-fragment="1"></iframe></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 另一个具有类似功能的软件是 Blender。它可以用来在两个选定的顶点之间“绘制”路径，但是它不允许像 3D-Coat 那样简单的调整。</span><span style="font-size: 12pt;">根据拓扑结构，UV 路径工具需要几分钟才能展开 UV。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 有一个基本原则：在隐蔽的地方，凹陷里或在锋利的边缘处切割 UV。然后就是 UV 排布，这个就不多说了。（虽然我没用过 3D-Coat，但是我觉得 unfold3D 应该是最好的展 UV 工具。）</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">BAKING&nbsp;&nbsp; 烘焙<br></span></strong></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 在这之后，我们需要准备我们的低模。对于大多数的扫描，这是一个更好的选项来设置所有的顶点或所有的多边形平滑，取决于所使用的 3D 软件。实时渲染引擎将处理整个网格平滑。这是最简单的方法，以避免稍后使用切线空间法线图（ tangent space normal map）。</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/001_BakingSmooth.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89152" src="https://cdn.80.lv/80.lv/uploads/2018/03/001_BakingSmooth.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="482" height="154"></a></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 我推荐 <a href="http://www.xnormal.net/" target="_blank" rel="noopener noreferrer" data-original-title="" title="">xNormal。&nbsp;</a>（emmm…..我推荐 knald。GPU 的快得一批！）</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 它是免费的，与商业工具相比有许多优点。允许在高模或低模上设置多边形的平滑度。它不需要 4-8Gb 的 VRAM 来烘焙 8k 纹理。可以使用 CPU 和 RAM 来烘焙超高分辨率的模型和巨大的贴图。</span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 打开 xNormal，通过拖拽到高分辨率网格窗口加载高模。设置“Average normals”。右击，选择“Base texture for bake”并添加纹理。</span></p><p align="justify"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/001_xNormal.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89156" src="https://cdn.80.lv/80.lv/uploads/2018/03/001_xNormal.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="979" height="693"></a></span></p><p align="justify"><span style="font-size: 12pt;">加载低模到 low-resolution meshes 窗口; 设置 “average normals“.</span></p><p align="justify"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/002_xNormal.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89160" src="https://cdn.80.lv/80.lv/uploads/2018/03/002_xNormal.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="979" height="693"></a></span></p><p align="justify"><span style="font-size: 12pt;">我们现在可以切换到 Tools 窗口并选择 ray distance calculator.。运行这将计算高低模的最小/最大距离。</span></p><p align="justify"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/004_xNormal.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89169" src="https://cdn.80.lv/80.lv/uploads/2018/03/004_xNormal.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="987" height="703"></a></span></p><p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-size: 12pt;">如果我们在前面的步骤都是对的，我们应该期望的是非常小的数字，比如 0.05。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 有时可能会出现很大的最大距离；这可能是由于一个或两个多边形的碰撞，或者高模上有<span class="op_dict_text2"> 尖状物</span>。在这种情况下，最好检查烘焙的纹理是否有错误。如果只有很小的错误，或者在 xNormal 中调整距离设置，然后再次烘焙，就可以在 Photoshop 中修复纹理。在我的大部分扫描中，我只在低模窗口设置了 0.1 的最小值和最大距离。</span></p><p><span style="font-size: 12pt;">在此之后，我们可以选择烘焙设置，纹理大小，render basket 大小和抗锯齿设置。最好为法线和 base color 设置最大 4x 采样。</span></p><p><span style="font-size: 12pt;">对于一个 AO 和 cavity，因为这些是不可见的，并且需要太多的计算时间，所以我们可以设置 1x 的值。</span></p><p>&nbsp;</p><p align="justify"><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/003_xNormal.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-full wp-image-89164" src="https://cdn.80.lv/80.lv/uploads/2018/03/003_xNormal.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="979" height="693"></a></span></p><p align="justify"><span style="font-size: 12pt;">开启 Normal map 烘焙 (计算 tangent space)和 Base color。</span></p><p align="justify"><span style="font-size: 12pt;">在 xNormal 全局设置里, 你可以在不同的图像格式中选择 8/16/32 bits。我喜欢 16bit 的 tiff.</span></p><p align="justify"></p><p align="justify"><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">烘焙 Normal map 和 Base color maps</span></strong></span></p><p align="justify"><span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp; 在此之后，在 Photoshop 中打开一个生成的法线贴图。检查所有的小细节，洞穴或多个小的元素，如手掌。如果我们设置错误的最小/最大距离，我们将不能看到连续的颜色。在这种情况下，需要调整最小/最大值设置。如果一切正常，下一步是删除 alpha 通道，并将最大压缩的图像保存为 PNG(无损，支持 16 位，比 ZIP tiff 更好压缩)。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 为了在 SketchFab 或 Marmoset Viewer 中使用，最好将映射的图像向下采样到 4k(如果原始数据是 8k)，保存一个 JPEG，以达到最大质量(在保存时图像将转换为 8bit)。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 回到 xNormal，禁用 Normal map 和 Base color maps，启用 AO 和 cavity map。然后把 x4 换成 x1。接下来烘焙这些贴图。这个过程非常缓慢，所以你可以最小化 xNormal，并减少它在任务管理器中的优先级。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 在 xNormal 完成烘焙 AO 和 cavity map 后，打开 Photoshop 中的 map，删除 alpha 通道，将 RGB 转换为灰度。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 在小细节的地方重复检查错误。接下来，将它保存为 8k PNG 文件归档，然后保存 2k 或 1k 的用于 SketcFab 或 Marmoset(因为阴影的细节不需要高分辨率，并且加载速度更快)。并保存与最大质量 JPG。</span></p><p>&nbsp;</p><p align="justify"><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">BASE COLOR TEXTURE</span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 如果你的镜头是正确的，并且你的相机是正确对齐的，那么纹理应该是非常好的，并且只需要在相机从一个高的角度捕捉到表面或者重建看不见的表面的地方。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 这个目的最好的工具是在 Photoshop 中使用 Content-Aware Fill（内容感知填充）或 Patch（修补）工具。。这些可以让你复制并将图像的另一部分融合到我们想要修复和重建的部分。</span><span style="font-size: 12pt;">这个过程需要技术和艺术技巧，尤其注重细节。你需要找到类似的、良好的图像部分，可以作为源使用，并尽可能地)使用 UV 贴图变形。</span><span style="font-size: 12pt;">你需要记住，所有的 UV 块都有延伸的边界，需要适当的渲染。特写渲染的时候可以看到一个像素的黑边。或者在实时引擎中使用，低级 MIP-maps 可以使这样的边缘清晰可见。这就是为什么边界如此重要(需要 8px 甚至更大)。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 对于恢复较大的区域，您可以使用 Content-Aware Fill（内容感知填充）或 Patch（修补）工具。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 如果你需要恢复在 UV 块之间的纹理，这可能会造成一些问题。在这种情况下，您需要创建另一个临时的 UV，将边缘合并到一个 UV，并且你可以连续地“绘制”一个新的纹理。首先，将纹理从高分辨率复制到临时的 UV 布局，然后恢复部分。然后从临时的 UV 贴图到工作的 UV 贴图，将校正后的纹理烘焙出来。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 你需要记住，所有新的纹理转换都删除了小细节。这就是为什么对临时 UV 贴图使用更高分辨率的原因。你甚至可以增加 UV 块的大小，你需要一个修复。并使用双尺寸分辨率- 16k 的临时贴图为 8k 工作贴图。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 之后，将固定的和原始的纹理与图层和 masks 融合在一起，通过掩盖在临时贴图中未被触摸的所有区域。</span><span style="font-size: 12pt;">因为这主要是用 Photoshop(或另一种首选工具)完成的，我们不会在本教程中介绍它，但我希望您能理解这个基本概念。（看完似懂非懂…….）</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">ASIDE&nbsp;&nbsp; 旁白<br></span></strong></span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 你可能发现在高分辨率的网格上使用 8bit 的源图像和纹理，并将其烘焙到 16 位，有点奇怪。是的，你没看错。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 如果你在预处理步骤中去除阴影和去光图像，那么 16 和 8bit 之间的区别仅仅是图像中 LSB 部分的噪点。这就是为什么我们可以使用 8bit 图像来贴图。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 任何纹理生成或烘焙步骤都有亚像素的转换，特别是当我们从 16/32k 纹理到 8/4K 的时候。这一步将总是添加额外 bit，16 位足够。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 在预处理步骤中，可能需要 16 位流程恢复阴影中的细节，我们不增加任何额外细节。</span></p><p><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 最有可能的是，由于这个工作流，我没有成功地使用 Unity Unlit 工具，因为纹理已经被去光，只需要小的技巧和颜色修正。任何颜色的纹理校正，最好在 16 位工作。</span></p><p><span style="font-size: 12pt;">&nbsp;如果你知道如何更好地使用 16/32bit 流程，为什么要阅读本教程?</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">SKETCHFAB&nbsp;&nbsp;&nbsp; （后面关于上传 Sketchfab 的，就不翻译了，有兴趣的可以自行翻译）<br></span></strong></span></p><p align="justify"><span style="font-size: 10pt;">At last, we have our low poly OBJ mesh.</span></p><p align="justify"><span style="font-size: 10pt;">For Sketchfab we’ll use 1-2K maps for the AO and cavity, 2-4K for normals and albedo (and if used 2-4K maps for specular/glossiness).</span></p><p align="justify"><span style="font-size: 10pt;">We can pack all files with 7zip (as a .zip or .7z archive) and upload them to SketchFab. Or simply pack the OBJ and MTL files, or only FBX mesh file. You can later add all the textures via the SketcFab 3D Editor.</span></p><p><span style="font-size: 10pt;">A useful trick: If you want to upload a “scene” to SketchFab containing more than one object, you will need to export all meshes as OBJ and create an empty file sketchfab.zbrush, then upload as an archive. In such case, SketchFab will treat the separate objects as one scene file.</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">SKETCHFAB 3D EDITOR</span></strong></span></p><p align="justify"><span style="font-size: 10pt;">I hope you have successfully added all the required materials to your model.</span></p><p align="justify"><span style="font-size: 10pt;">Normals from xNormal usually don’t require a Y-flip.</span></p><p align="justify"><span style="font-size: 10pt;">Ambient Occlusion looks better with “Occlude specularity” ON and at 80-90%. Cavity with 50%.</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/001_SF.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89155" src="https://cdn.80.lv/80.lv/uploads/2018/03/001_SF.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="589"></a></span></p><p align="justify"><span style="font-size: 10pt;">Next, we need to talk about the lights and background.</span></p><p align="justify"><span style="font-size: 10pt;">Because our scene is a 3D scan, the lights, environment, and background need to be selected wisely. We want to show a good picture or mood, but at the same time show the scanned object and all its details. Sometimes seeing a good scan is the only way for people around the world to see some unique objects or world heritage artifacts.</span></p><p align="justify"><span style="font-size: 10pt;">This means that the background should not clash with the hero of our story – scanned the object. The used lights need to contribute to the details of the object.</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/004_SF.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89168" src="https://cdn.80.lv/80.lv/uploads/2018/03/004_SF.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="587"></a></span></p><p align="justify"><span style="font-size: 10pt;">Light can be generated from an environment map and can create a shadow, so you don’t need to use additional light.</span></p><p align="justify"><span style="font-size: 10pt;">But If you can set up proper lights, your model will look very realistic.</span></p><p align="justify"><span style="font-size: 10pt;">I personally love the dark or light grey clean SketchFab background. But seeing interesting combinations of photos of scanned places and objects can look good too.</span></p><p align="justify"><span style="font-size: 10pt;">The Blurred Environment map as a background usually looks cheap and boring, and you’ll have to work on creating something better.</span></p><p align="justify"></p><p align="justify"><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">POST-PROCESSING</span></strong></span></p><p align="justify"><span style="font-size: 10pt;">A post-process filter that can be used without causing problems on the scans is the Sharpen, and its default settings are usually enough.</span></p><p align="justify"><span style="font-size: 10pt;">SSAO (Screen space ambient occlusion) can look very interesting, but it is a bit strong for my taste. Also, as we have pre-baked AO and cavity, the additional SSAO effect is not needed.</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/002_SF.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89159" src="./Photogrammetry 完全指南_files/002_SF-1024x588.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="588"></a></span></p><p align="justify"><span style="font-size: 10pt;">I strongly recommend avoiding using DOF, aberrations, or other strong post-processing effects that can destroy the charm of a good scan.</span></p><p align="justify"><span style="font-size: 10pt;">To be honest: If you see any of these effects in combination with the Shadeless mode, this most likely means that the scan has gone bad or has a low quality, and the author needs to hide as much of it as possible.</span></p><p align="justify"><span style="font-size: 10pt;">The same goes for camera restrictions. In my opinion, if you don’t want to show all 360 degrees of the scanned object – simply use still renders or video.</span></p><p><span style="font-size: 10pt;"><a class="fancybox aligncenter" href="https://cdn.80.lv/80.lv/uploads/2018/03/005_SF.png" title="" rel="box" target="_blank" data-original-title="Photogrammetry 完全指南"><img class="aligncenter size-large wp-image-89172" src="./Photogrammetry 完全指南_files/005_SF-1024x588.png" alt="Photogrammetry 完全指南" title="Photogrammetry 完全指南" width="1024" height="588"></a></span></p><p align="justify"><span style="font-size: 10pt;">Next, save the scene. This can take some time if we have added textures (they are needed to be uploaded).</span></p><p align="justify"><span style="font-size: 10pt;">Then exit to view mode.</span></p><p align="justify"><span style="font-size: 10pt;">Do not skip adding a nice description, and maybe some details regarding the used software and hardware like cameras, lens, number of images, etc.</span></p><p align="justify"><span style="font-size: 10pt;">Also, add tags with names of used software. This is helpful to other users that are searching <a href="https://www.iiicg.com/archives/tag/photogrammetry" title="" target="_blank" data-original-title="查看更多关于 photogrammetry 的文章">photogrammetry</a> tools and helps them understand the Pros and Cons of the modern <a href="https://www.iiicg.com/archives/tag/photogrammetry" title="" target="_blank" data-original-title="查看更多关于 photogrammetry 的文章">photogrammetry</a> software by browsing through the SketchFab.</span></p><p align="justify"><span style="font-size: 10pt;">Finally, Scale and Rotate the scene in the view window, and save the correct view with the left top Save View button.</span></p><p align="justify"><span style="font-size: 10pt;">Double check all the text, press Publish and wait for likes or maybe a Staff Pick .</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">RESOURCES&nbsp;&nbsp; 资源<br></span></strong></span></p><p align="justify"><span style="font-size: 12pt;">如果你想了解更多关于 RealityCapture、<a href="https://www.iiicg.com/archives/tag/photogrammetry" title="" target="_blank" data-original-title="查看更多关于 photogrammetry 的文章">photogrammetry</a> 或 3Dscanning 的信息， 欢迎访问 <a href="https://support.capturingreality.com/hc/en-us/community/topics" target="_blank" rel="noopener noreferrer" data-original-title="" title="">Capturing Reality Forum.</a></span></p><p><span style="font-size: 12pt;">或者在 Facebook 上找到更多这样的群组:</span></p><ul><li><span style="font-size: 12pt;"><a href="https://www.facebook.com/groups/3dsug/" target="_blank" rel="noopener noreferrer" data-original-title="" title="">3D scanning user group</a></span></li><li><span style="font-size: 12pt;"><a href="https://www.facebook.com/groups/CapturingRealityArena/" target="_blank" rel="noopener noreferrer" data-original-title="" title="">Capturing Reality Arena</a></span></li></ul><p align="justify"><span style="font-size: 12pt;">在这里你不仅可以找到我，还可以找到许多其他的摄影测量和 3D 扫描的专家，VFX 和 VR/AR。</span></p><p align="justify"><span style="font-size: 12pt;">一定要先搜索和阅读，因为你会发现很多有用的东西，而且大多数问题已经被问到和回答了。</span></p><p>&nbsp;</p><p><span style="color: #99cc00;"><strong><span style="font-size: 14pt;">ABOUT THE AUTHOR&nbsp;&nbsp;&nbsp; 关于作者<br></span></strong></span></p><p><strong><a href="https://www.artstation.com/ssh4" target="_blank" rel="noopener noreferrer" data-original-title="" title="">Vlad Kuzmin</a></strong></p><p>出生于苏联，列宁格勒(圣彼得堡)，1970 年代。擅长设计，UI/UX 设计，广告，摄影测量，和 3d 视觉。认证的 Adobe ACE/ RealityCapture 和摄影测量专家。快速找到和混合不同的技术从不同的设计部门，以获得成功的最有效的方式。</p><p>在过去的 5 年里在日本生活和工作。曾在一家日本电子游戏公司担任 UI/UX 设计师。在过去的一年里，他把时间都花在了东京 Avatta 工作室(avatta.net)的摄影测量上。Avatta 的客户包括 Sega, Sony Computer Entertainment, NHK, Amazon Japan 等，公司拥有全国最好的全身和面部摄像设备。</p><hr>译者及时更新，欢迎大家阅读后发表评论，以利作品的完善。属在本网站发表的文章,</article></div>,.</div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Photogrammetry 完全指南&lt;br&gt;Vlad Kuzmin 分享了很多摄影测量的技巧。学习如何扫描真实世界的物体，清理和渲染。.&lt;br&gt;
    
    </summary>
    
      <category term="Photogrammetry" scheme="https://myblong.zkb/categories/Photogrammetry/"/>
    
    
      <category term="分享" scheme="https://myblong.zkb/tags/%E5%88%86%E4%BA%AB/"/>
    
      <category term="Photogrammetry 完全指南" scheme="https://myblong.zkb/tags/Photogrammetry-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>【工作流研发类】Nuke TCL语言手册分享</title>
    <link href="https://myblong.zkb/2019/06/09/workflow/%E3%80%90%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A0%94%E5%8F%91%E7%B1%BB%E3%80%91Nuke%20TCL%E8%AF%AD%E8%A8%80%E6%89%8B%E5%86%8C%E5%88%86%E4%BA%AB/"/>
    <id>https://myblong.zkb/2019/06/09/workflow/【工作流研发类】Nuke TCL语言手册分享/</id>
    <published>2019-06-09T03:26:02.830Z</published>
    <updated>2019-06-09T03:35:12.610Z</updated>
    
    <content type="html"><![CDATA[<p>*</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><em>前言</em></h2><p><em><br>    这是一份关于Nuke TCL语言（Tool Command Language）详细使用案例说明，可点击下面这个链接。对于nuke一些脚本工具的开发有很大的帮助。<br><a href="http://tmml.sourceforge.net/doc/tcl/" target="_blank" rel="external">http://tmml.sourceforge.net/doc/tcl/</a><br><a id="more"></a><br><img src="https://note.youdao.com/yws/res/222/WEBRESOURCE7a095fc4dc24c76438cdb65875d01eef" alt=""><br><em>*什么是 NUKE TCL</em></em></p><h2 id="…-Nuke-TCL语言有点类似于Maya-MEL和Houdini-HScripts，编程语言万变不离其宗，都有变量，数据类型，内置函数，函数传参，流控制语句以及自定义函数等这些共通的东西，所以写起来并不麻烦，比如现在想获取当前nk文件的上上个文件夹的层级路径就可以这样来写"><a href="#…-Nuke-TCL语言有点类似于Maya-MEL和Houdini-HScripts，编程语言万变不离其宗，都有变量，数据类型，内置函数，函数传参，流控制语句以及自定义函数等这些共通的东西，所以写起来并不麻烦，比如现在想获取当前nk文件的上上个文件夹的层级路径就可以这样来写" class="headerlink" title=". .. …..Nuke TCL语言有点类似于Maya MEL和Houdini HScripts，编程语言万变不离其宗，都有变量，数据类型，内置函数，函数传参，流控制语句以及自定义函数等这些共通的东西，所以写起来并不麻烦，比如现在想获取当前nk文件的上上个文件夹的层级路径就可以这样来写."></a>. .. …..Nuke TCL语言有点类似于Maya MEL和Houdini HScripts，编程语言万变不离其宗，都有变量，数据类型，内置函数，函数传参，流控制语句以及自定义函数等这些共通的东西，所以写起来并不麻烦，比如现在想获取当前nk文件的上上个文件夹的层级路径就可以这样来写.</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取当前nk文件的路径</span></div><div class="line">[value root.name]</div><div class="line"><span class="comment"># 获取当前nk文件所在的文件夹路径</span></div><div class="line">[file dirname [value root.name]]</div><div class="line"><span class="comment"># 获取当前文件路径任何一个层级的路径</span></div><div class="line">[join [lrange [split [file dirname [value root.name]] /] <span class="number">0</span> end<span class="number">-1</span>] /]</div></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/res/218/WEBRESOURCE943311ac450c82fe70b0be71780c2408" alt=""></p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取指定节点的参数值:</span></div><div class="line">[value Read1.first]</div><div class="line"></div><div class="line"><span class="comment"># 获取当前节点的参数值:</span></div><div class="line">[value this.size]</div><div class="line"></div><div class="line"><span class="comment"># 设置指定节点的参数值:</span></div><div class="line">[knob Read1.first <span class="number">10</span>]</div><div class="line"></div><div class="line"><span class="comment"># 获取当前节点的第一帧:</span></div><div class="line">[value this.first_frame]</div><div class="line"></div><div class="line"><span class="comment"># 设置TCL变量:</span></div><div class="line">[set tsize <span class="number">15</span>]</div><div class="line"></div><div class="line"><span class="comment"># 之后可以用$的方式使用该变量来设置参数值:</span></div><div class="line">[knob this.size $tsize]</div><div class="line"></div><div class="line"><span class="comment"># 获取上游节点的名称:</span></div><div class="line">[value this.input.name]</div><div class="line"></div><div class="line"><span class="comment"># 获取Group节点上游节点的名称:</span></div><div class="line">[value this.parent.input.name]</div><div class="line"></div><div class="line"><span class="comment"># 获取不带扩展名的文件路径:</span></div><div class="line">[file rootname [value [topnode].file]]</div><div class="line"></div><div class="line"><span class="comment"># 获取文件名:</span></div><div class="line">[basename [value [topnode].file]]</div><div class="line"></div><div class="line"><span class="comment"># 获取不带扩展名的文件名:</span></div><div class="line">[basename [file rootname [value [topnode].file]]]</div><div class="line"></div><div class="line"><span class="comment"># 通过join和lrange来重新生成想要的文件夹路径(这个类似Python中字符串的split和join的功能):</span></div><div class="line">[join [lrange [file split [value [topnode].file]] <span class="number">0</span> <span class="number">7</span>] /]</div><div class="line"></div><div class="line"><span class="comment"># 快速将Read节点中文件输出到同层级下tga的格式文件</span></div><div class="line">[join [lrange [split [value [topnode].file] .] <span class="number">0</span> end<span class="number">-2</span>] .].%<span class="number">04</span>d.tga</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;*&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;em&gt;前言&lt;/em&gt;&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&lt;br&gt;    这是一份关于Nuke TCL语言（Tool Command Language）详细使用案例说明，可点击下面这个链接。对于nuke一些脚本工具的开发有很大的帮助。&lt;br&gt;&lt;a href=&quot;http://tmml.sourceforge.net/doc/tcl/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tmml.sourceforge.net/doc/tcl/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="nuke相关" scheme="https://myblong.zkb/categories/nuke%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="nuke" scheme="https://myblong.zkb/tags/nuke/"/>
    
      <category term="TCL" scheme="https://myblong.zkb/tags/TCL/"/>
    
      <category term="帮助手册" scheme="https://myblong.zkb/tags/%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>mari3,如何创建模型的id通道</title>
    <link href="https://myblong.zkb/2019/06/09/mari3,%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B%E7%9A%84id%E9%80%9A%E9%81%93/"/>
    <id>https://myblong.zkb/2019/06/09/mari3,如何创建模型的id通道/</id>
    <published>2019-06-08T17:27:52.556Z</published>
    <updated>2019-06-09T03:39:03.987Z</updated>
    
    <content type="html"><![CDATA[<p>**</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>**</p><p>写一些分享之前我是个人习惯喜欢加一个前言，说说自己的感受，目前mari已经更新到4.5了，有些同学还用以前的，当然主要因为目前3的扩展包网上能找到和谐版吧，不管什么原因，我就介绍一下我一些常用的方法了。我这个不是从最基础开始的，需要有一定的使用基础。我本人接触的东西也比较杂，因为是程序出身，接触过最多的是maya平台的一些流程开发，在艺术方面，主要是场景模型资产和纹理的创建，所以在有些地方会有一些比较特别的想法和经验吧。以后有问题可以互相交流探讨。这里我就简单的阐述一下mari中创建id通道的一种方法，当然方法比较多。灵活运用就好。<br><a id="more"></a></p><h2 id="为什么要创建id"><a href="#为什么要创建id" class="headerlink" title="为什么要创建id"></a>为什么要创建id</h2><p>至于为什么要创建，我想大概用过sp的人大概已经知道了原因了，简单的来说，就是把一个资产分组，按材质的类型等分开，在mari里面单独的去处理每一个部分的纹理，而不影响其他地方。</p><p><strong>创建id的方法有那些</strong></p><p>目前我所知道的是5种，当然是有比较麻烦和快捷的。mari的三种方式，和maya中的两种，稍后会说明</p><p><strong>具体操作部分</strong></p><p>Mari中，比较直接的方式是用selection groups选择组的方式，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/17107200-81513ba842a5fa17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/943/format/webp" alt=""></p><p>这种方法是比较直接和快捷的，真直观的选择需要的部分进行创建，当然要绘制在模型表面的选区就不行了。所有就有了第二种方法：<br><img src="https://upload-images.jianshu.io/upload_images/17107200-55d7ffcc7bcdc05a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/382/format/webp" alt=""></p><p>新建一个组，在组上创建一个mask，把属于这个身体的操作都放在这个组内去绘制，当然mask的形态也可以直接去调整。</p><p>第三种方法，就是用Mari的扩展包了，这个就非常方便快捷的创建遮罩，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;**&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;**&lt;/p&gt;
&lt;p&gt;写一些分享之前我是个人习惯喜欢加一个前言，说说自己的感受，目前mari已经更新到4.5了，有些同学还用以前的，当然主要因为目前3的扩展包网上能找到和谐版吧，不管什么原因，我就介绍一下我一些常用的方法了。我这个不是从最基础开始的，需要有一定的使用基础。我本人接触的东西也比较杂，因为是程序出身，接触过最多的是maya平台的一些流程开发，在艺术方面，主要是场景模型资产和纹理的创建，所以在有些地方会有一些比较特别的想法和经验吧。以后有问题可以互相交流探讨。这里我就简单的阐述一下mari中创建id通道的一种方法，当然方法比较多。灵活运用就好。&lt;br&gt;
    
    </summary>
    
      <category term="mair相关" scheme="https://myblong.zkb/categories/mair%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="贴图" scheme="https://myblong.zkb/tags/%E8%B4%B4%E5%9B%BE/"/>
    
      <category term="mari" scheme="https://myblong.zkb/tags/mari/"/>
    
  </entry>
  
</feed>
